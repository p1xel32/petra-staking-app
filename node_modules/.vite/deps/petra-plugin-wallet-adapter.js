import {
  aptos_types_exports,
  bcs_exports,
  h,
  init_buffer as init_buffer2,
  require_nacl_fast
} from "./chunk-FI7TMQVG.js";
import {
  B,
  U4 as U,
  V,
  Wn,
  a3 as a,
  e,
  l2 as l,
  s4 as s
} from "./chunk-5AC4UWVF.js";
import "./chunk-IZIMFVKE.js";
import {
  __commonJS,
  __toESM,
  init_buffer,
  init_process
} from "./chunk-O5XV4B72.js";

// node_modules/petra-plugin-wallet-adapter/node_modules/eventemitter3/index.js
var require_eventemitter3 = __commonJS({
  "node_modules/petra-plugin-wallet-adapter/node_modules/eventemitter3/index.js"(exports, module) {
    "use strict";
    init_process();
    init_buffer();
    var has = Object.prototype.hasOwnProperty;
    var prefix = "~";
    function Events() {
    }
    if (Object.create) {
      Events.prototype = /* @__PURE__ */ Object.create(null);
      if (!new Events().__proto__) prefix = false;
    }
    function EE(fn, context, once) {
      this.fn = fn;
      this.context = context;
      this.once = once || false;
    }
    function addListener(emitter, event, fn, context, once) {
      if (typeof fn !== "function") {
        throw new TypeError("The listener must be a function");
      }
      var listener = new EE(fn, context || emitter, once), evt = prefix ? prefix + event : event;
      if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;
      else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);
      else emitter._events[evt] = [emitter._events[evt], listener];
      return emitter;
    }
    function clearEvent(emitter, evt) {
      if (--emitter._eventsCount === 0) emitter._events = new Events();
      else delete emitter._events[evt];
    }
    function EventEmitter3() {
      this._events = new Events();
      this._eventsCount = 0;
    }
    EventEmitter3.prototype.eventNames = function eventNames() {
      var names = [], events, name;
      if (this._eventsCount === 0) return names;
      for (name in events = this._events) {
        if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);
      }
      if (Object.getOwnPropertySymbols) {
        return names.concat(Object.getOwnPropertySymbols(events));
      }
      return names;
    };
    EventEmitter3.prototype.listeners = function listeners(event) {
      var evt = prefix ? prefix + event : event, handlers = this._events[evt];
      if (!handlers) return [];
      if (handlers.fn) return [handlers.fn];
      for (var i2 = 0, l2 = handlers.length, ee = new Array(l2); i2 < l2; i2++) {
        ee[i2] = handlers[i2].fn;
      }
      return ee;
    };
    EventEmitter3.prototype.listenerCount = function listenerCount(event) {
      var evt = prefix ? prefix + event : event, listeners = this._events[evt];
      if (!listeners) return 0;
      if (listeners.fn) return 1;
      return listeners.length;
    };
    EventEmitter3.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt]) return false;
      var listeners = this._events[evt], len = arguments.length, args, i2;
      if (listeners.fn) {
        if (listeners.once) this.removeListener(event, listeners.fn, void 0, true);
        switch (len) {
          case 1:
            return listeners.fn.call(listeners.context), true;
          case 2:
            return listeners.fn.call(listeners.context, a1), true;
          case 3:
            return listeners.fn.call(listeners.context, a1, a2), true;
          case 4:
            return listeners.fn.call(listeners.context, a1, a2, a3), true;
          case 5:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
          case 6:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
        }
        for (i2 = 1, args = new Array(len - 1); i2 < len; i2++) {
          args[i2 - 1] = arguments[i2];
        }
        listeners.fn.apply(listeners.context, args);
      } else {
        var length = listeners.length, j;
        for (i2 = 0; i2 < length; i2++) {
          if (listeners[i2].once) this.removeListener(event, listeners[i2].fn, void 0, true);
          switch (len) {
            case 1:
              listeners[i2].fn.call(listeners[i2].context);
              break;
            case 2:
              listeners[i2].fn.call(listeners[i2].context, a1);
              break;
            case 3:
              listeners[i2].fn.call(listeners[i2].context, a1, a2);
              break;
            case 4:
              listeners[i2].fn.call(listeners[i2].context, a1, a2, a3);
              break;
            default:
              if (!args) for (j = 1, args = new Array(len - 1); j < len; j++) {
                args[j - 1] = arguments[j];
              }
              listeners[i2].fn.apply(listeners[i2].context, args);
          }
        }
      }
      return true;
    };
    EventEmitter3.prototype.on = function on(event, fn, context) {
      return addListener(this, event, fn, context, false);
    };
    EventEmitter3.prototype.once = function once(event, fn, context) {
      return addListener(this, event, fn, context, true);
    };
    EventEmitter3.prototype.removeListener = function removeListener(event, fn, context, once) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt]) return this;
      if (!fn) {
        clearEvent(this, evt);
        return this;
      }
      var listeners = this._events[evt];
      if (listeners.fn) {
        if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {
          clearEvent(this, evt);
        }
      } else {
        for (var i2 = 0, events = [], length = listeners.length; i2 < length; i2++) {
          if (listeners[i2].fn !== fn || once && !listeners[i2].once || context && listeners[i2].context !== context) {
            events.push(listeners[i2]);
          }
        }
        if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;
        else clearEvent(this, evt);
      }
      return this;
    };
    EventEmitter3.prototype.removeAllListeners = function removeAllListeners(event) {
      var evt;
      if (event) {
        evt = prefix ? prefix + event : event;
        if (this._events[evt]) clearEvent(this, evt);
      } else {
        this._events = new Events();
        this._eventsCount = 0;
      }
      return this;
    };
    EventEmitter3.prototype.off = EventEmitter3.prototype.removeListener;
    EventEmitter3.prototype.addListener = EventEmitter3.prototype.on;
    EventEmitter3.prefixed = prefix;
    EventEmitter3.EventEmitter = EventEmitter3;
    if ("undefined" !== typeof module) {
      module.exports = EventEmitter3;
    }
  }
});

// node_modules/petra-plugin-wallet-adapter/dist/index.mjs
init_process();
init_buffer();

// node_modules/petra-plugin-wallet-adapter/node_modules/@aptos-labs/wallet-adapter-core/dist/index.mjs
init_process();
init_buffer();
var import_eventemitter3 = __toESM(require_eventemitter3(), 1);

// node_modules/petra-plugin-wallet-adapter/node_modules/@aptos-labs/wallet-standard/dist/esm/index.mjs
init_process();
init_buffer();

// node_modules/petra-plugin-wallet-adapter/node_modules/@aptos-labs/wallet-standard/dist/esm/chunk-6Z4OTACZ.mjs
init_process();
init_buffer();

// node_modules/petra-plugin-wallet-adapter/node_modules/@aptos-labs/wallet-standard/dist/esm/chunk-FTWFFAUO.mjs
init_process();
init_buffer();

// node_modules/petra-plugin-wallet-adapter/node_modules/@aptos-labs/wallet-standard/dist/esm/chunk-PFVDO7Z5.mjs
init_process();
init_buffer();

// node_modules/petra-plugin-wallet-adapter/node_modules/@aptos-labs/wallet-standard/dist/esm/chunk-IKEWF26U.mjs
init_process();
init_buffer();

// node_modules/petra-plugin-wallet-adapter/node_modules/@aptos-labs/wallet-standard/dist/esm/chunk-MUCP3CGX.mjs
init_process();
init_buffer();

// node_modules/petra-plugin-wallet-adapter/node_modules/@aptos-labs/wallet-standard/dist/esm/chunk-KS6LLZYA.mjs
init_process();
init_buffer();

// node_modules/petra-plugin-wallet-adapter/node_modules/@aptos-labs/wallet-standard/dist/esm/chunk-5VNONCYO.mjs
init_process();
init_buffer();

// node_modules/petra-plugin-wallet-adapter/node_modules/@aptos-labs/wallet-standard/dist/esm/chunk-IJRVYSIU.mjs
init_process();
init_buffer();

// node_modules/petra-plugin-wallet-adapter/node_modules/@aptos-labs/wallet-standard/dist/esm/chunk-3ZGVLQDX.mjs
init_process();
init_buffer();

// node_modules/petra-plugin-wallet-adapter/node_modules/@aptos-labs/wallet-standard/dist/esm/chunk-7D3WXB36.mjs
init_process();
init_buffer();

// node_modules/petra-plugin-wallet-adapter/node_modules/@aptos-labs/wallet-standard/dist/esm/chunk-OXEBULP4.mjs
init_process();
init_buffer();

// node_modules/petra-plugin-wallet-adapter/node_modules/@aptos-labs/wallet-standard/dist/esm/chunk-FFGPGN2W.mjs
init_process();
init_buffer();

// node_modules/petra-plugin-wallet-adapter/node_modules/@aptos-labs/wallet-standard/dist/esm/chunk-XXN63NEC.mjs
init_process();
init_buffer();

// node_modules/petra-plugin-wallet-adapter/node_modules/@aptos-labs/wallet-standard/dist/esm/chunk-3XZSACFC.mjs
init_process();
init_buffer();

// node_modules/petra-plugin-wallet-adapter/node_modules/@aptos-labs/wallet-standard/dist/esm/chunk-7OMCNXQ7.mjs
init_process();
init_buffer();

// node_modules/petra-plugin-wallet-adapter/node_modules/@wallet-standard/core/lib/esm/index.js
init_process();
init_buffer();

// node_modules/petra-plugin-wallet-adapter/node_modules/@aptos-labs/wallet-standard/dist/esm/chunk-KFHNVTDM.mjs
init_process();
init_buffer();
var n = ((e6) => (e6[e6.Unauthorized = 4100] = "Unauthorized", e6[e6.InternalError = -30001] = "InternalError", e6))(n || {});
var t = Object.freeze({ 4100: { status: "Unauthorized", message: "The requested method and/or account has not been authorized by the user." }, [-30001]: { status: "Internal error", message: "Something went wrong within the wallet." } });

// node_modules/petra-plugin-wallet-adapter/node_modules/@aptos-labs/wallet-standard/dist/esm/chunk-YVBEQ4QF.mjs
init_process();
init_buffer();
var r = ((e6) => (e6.APPROVED = "Approved", e6.REJECTED = "Rejected", e6))(r || {});

// node_modules/petra-plugin-wallet-adapter/node_modules/@aptos-labs/wallet-standard/dist/esm/chunk-4PSZV2RG.mjs
init_process();
init_buffer();

// node_modules/petra-plugin-wallet-adapter/node_modules/@aptos-labs/wallet-adapter-core/dist/index.mjs
var import_eventemitter32 = __toESM(require_eventemitter3(), 1);
init_buffer2();
var import_tweetnacl = __toESM(require_nacl_fast(), 1);
var WALLET_ADAPTER_CORE_VERSION = "3.16.0";
var sdkWallets = [];
sdkWallets.push(new h());
var WalletReadyState = ((WalletReadyState2) => {
  WalletReadyState2["Installed"] = "Installed";
  WalletReadyState2["NotDetected"] = "NotDetected";
  WalletReadyState2["Loadable"] = "Loadable";
  WalletReadyState2["Unsupported"] = "Unsupported";
  return WalletReadyState2;
})(WalletReadyState || {});
var NetworkName = ((NetworkName2) => {
  NetworkName2["Mainnet"] = "mainnet";
  NetworkName2["Testnet"] = "testnet";
  NetworkName2["Devnet"] = "devnet";
  return NetworkName2;
})(NetworkName || {});
var areBCSArguments = (args) => {
  if (args.length === 0)
    return false;
  return args.every(
    (arg) => arg instanceof B
  );
};
if (typeof window !== "undefined") {
  window.WALLET_ADAPTER_CORE_VERSION = WALLET_ADAPTER_CORE_VERSION;
}

// node_modules/petra-plugin-wallet-adapter/dist/index.mjs
function convertV1toV2(src, dst) {
  const serializedBytes = bcs_exports.bcsToBytes(src);
  const deserializerV2 = new a(serializedBytes);
  return dst.deserialize(deserializerV2);
}
function convertV2toV1(src, dst) {
  const serializedBytes = src.bcsToBytes();
  const deserializerV1 = new bcs_exports.Deserializer(serializedBytes);
  return dst.deserialize(deserializerV1);
}
function convertNetwork(networkInfo) {
  switch (networkInfo == null ? void 0 : networkInfo.name.toLowerCase()) {
    case "mainnet":
      return e.MAINNET;
    case "testnet":
      return e.TESTNET;
    case "devnet":
      return e.DEVNET;
    default:
      throw new Error("Invalid network name");
  }
}
function convertV2JsonPayloadToV1(payload) {
  var _a;
  if ("bytecode" in payload) {
    throw new Error("script payload not supported");
  }
  const stringTypeTags = (_a = payload.typeArguments) == null ? void 0 : _a.map(
    (typeTag) => {
      if (typeTag instanceof U) {
        return typeTag.toString();
      }
      return typeTag;
    }
  );
  return {
    type: "entry_function_payload",
    function: payload.function,
    type_arguments: stringTypeTags || [],
    arguments: payload.functionArguments
  };
}
async function generateV1TransactionPayload(payloadData, network) {
  const aptosConfig = new s({
    network: convertNetwork(network)
  });
  const newPayload = await Wn({
    ...payloadData,
    aptosConfig
  });
  return convertV2toV1(newPayload, aptos_types_exports.TransactionPayload);
}
var PetraApiError = class extends Error {
  constructor(code, status, message) {
    super(message);
    this.code = code;
    this.status = status;
    this.status = status;
    this.code = code;
    Object.setPrototypeOf(this, PetraApiError.prototype);
  }
};
var PetraApiErrors = Object.freeze({
  INTERNAL_ERROR: new PetraApiError(-30001, "Internal Error", "Internal Error"),
  NO_ACCOUNTS: new PetraApiError(4e3, "No Accounts", "No accounts found"),
  TIME_OUT: new PetraApiError(
    4002,
    "Time Out",
    "The prompt timed out without a response. This could be because the user did not respond or because a new request was opened."
  ),
  UNAUTHORIZED: new PetraApiError(
    4100,
    "Unauthorized",
    "The requested method and/or account has not been authorized by the user."
  ),
  UNSUPPORTED: new PetraApiError(
    4200,
    "Unsupported",
    "The provider does not support the requested method."
  ),
  USER_REJECTION: new PetraApiError(
    4001,
    "Rejected",
    "The user rejected the request"
  )
});
function codeToError(code) {
  return Object.values(PetraApiErrors).find((error) => error.code === code) ?? PetraApiErrors.INTERNAL_ERROR;
}
function isObjectPropsUnsupportedError(err) {
  return err instanceof Error && err.message === "Cannot read properties of undefined (reading 'map')";
}
function areOptionsEmpty(options) {
  return options === void 0 || Object.keys(options).length === 0 || Object.values(options).every((v) => v === void 0);
}
function remapPetraError(error) {
  if ("code" in error) {
    throw codeToError(error.code);
  }
  throw error;
}
function remapTransactionOptions(options) {
  return {
    maxGasAmount: (options == null ? void 0 : options.max_gas_amount) ? Number(options == null ? void 0 : options.max_gas_amount) : void 0,
    gasUnitPrice: (options == null ? void 0 : options.gas_unit_price) ? Number(options == null ? void 0 : options.gas_unit_price) : void 0,
    ...options
  };
}
var PetraWalletName = "Petra";
var PetraWallet = class {
  constructor() {
    this.name = PetraWalletName;
    this.version = "v2";
    this.url = "https://chrome.google.com/webstore/detail/petra-aptos-wallet/ejjladinnckdgjemekebdpeokbikhfci";
    this.icon = "data:image/png;base64,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";
    this.provider = typeof window !== "undefined" ? window.petra : void 0;
  }
  deeplinkProvider(data) {
    return `https://petra.app/explore?link=${data.url}`;
  }
  async connect() {
    const addressInfo = await this.provider.connect().catch(remapPetraError);
    if (!addressInfo)
      throw `${PetraWalletName} Address Info Error`;
    return addressInfo;
  }
  async account() {
    const response = await this.provider.account().catch(remapPetraError);
    if (!response)
      throw `${PetraWalletName} Account Error`;
    return response;
  }
  async disconnect() {
    return this.provider.disconnect().catch(remapPetraError);
  }
  async signAndSubmitTransaction(payloadV1OrGenerateTxnInput, optionsV1) {
    var _a;
    if ("data" in payloadV1OrGenerateTxnInput) {
      const generateTxnInput = payloadV1OrGenerateTxnInput;
      const options = {
        expirationTimestamp: (_a = generateTxnInput.options) == null ? void 0 : _a.expireTimestamp,
        sender: generateTxnInput.sender ? l.from(generateTxnInput.sender).toString() : void 0,
        ...generateTxnInput.options
      };
      if (areBCSArguments(generateTxnInput.data.functionArguments)) {
        const network = await this.network();
        const payload2 = await generateV1TransactionPayload(generateTxnInput.data, network);
        return await this.signAndSubmitBCSTransaction(payload2, options);
      }
      const payload = await convertV2JsonPayloadToV1(generateTxnInput.data);
      return await this.signAndSubmitTransaction(payload, options);
    }
    const payloadV1 = payloadV1OrGenerateTxnInput;
    const response = await this.provider.signAndSubmitTransaction(
      payloadV1,
      optionsV1 ? remapTransactionOptions(optionsV1) : void 0
    ).catch(remapPetraError);
    return response;
  }
  async signAndSubmitBCSTransaction(payload, options) {
    if (!areOptionsEmpty(options)) {
      try {
        const response2 = await this.provider.signAndSubmitTransaction(
          {
            payload,
            options: remapTransactionOptions(options)
          }
        ).catch(remapPetraError);
        return response2;
      } catch (err) {
        if (!isObjectPropsUnsupportedError(err)) {
          throw err;
        }
        console.warn("Options are not supported by your current version of Petra and they will be ignored. Please update to Petra >= 1.2.27.\nIgnored options: ", options);
      }
    }
    const response = await this.provider.signAndSubmitTransaction(
      payload
    ).catch(remapPetraError);
    return response;
  }
  async signMessage(message) {
    if (typeof message !== "object" || !message.nonce) {
      throw `${PetraWalletName} Invalid signMessage Payload`;
    }
    return this.provider.signMessage(message).catch(remapPetraError);
  }
  async signTransaction(transactionOrPayload, optionsOrAsFeePayer) {
    var _a;
    if ("rawTransaction" in transactionOrPayload) {
      const transaction = transactionOrPayload;
      const asFeePayer = optionsOrAsFeePayer ?? false;
      const rawTxnV1 = convertV2toV1(transaction.rawTransaction, aptos_types_exports.RawTransaction);
      const secondarySignersAddressesV1 = (_a = transaction.secondarySignerAddresses) == null ? void 0 : _a.map(
        (address) => convertV2toV1(address, aptos_types_exports.AccountAddress)
      );
      let rawTxn;
      if (asFeePayer) {
        const activeAccount = await this.account();
        const feePayerAddressV1 = aptos_types_exports.AccountAddress.fromHex(activeAccount.address);
        rawTxn = new aptos_types_exports.FeePayerRawTransaction(
          rawTxnV1,
          secondarySignersAddressesV1 ?? [],
          feePayerAddressV1
        );
      } else if (transaction.feePayerAddress) {
        const feePayerAddressV1 = convertV2toV1(transaction.feePayerAddress, aptos_types_exports.AccountAddress);
        rawTxn = new aptos_types_exports.FeePayerRawTransaction(
          rawTxnV1,
          secondarySignersAddressesV1 ?? [],
          feePayerAddressV1
        );
      } else if (secondarySignersAddressesV1) {
        rawTxn = new aptos_types_exports.MultiAgentRawTransaction(
          rawTxnV1,
          secondarySignersAddressesV1
        );
      } else {
        rawTxn = rawTxnV1;
      }
      try {
        const { accountAuthenticator } = await this.provider.signTransaction(
          { rawTxn }
        ).catch(remapPetraError);
        return convertV1toV2(accountAuthenticator, V);
      } catch (err) {
        if (isObjectPropsUnsupportedError(err)) {
          throw new Error("Signing an arbitrary raw transaction is not supported by your current version of Petra. Please update to Petra >= 1.2.27.");
        }
        throw err;
      }
    }
    const payload = transactionOrPayload;
    const options = optionsOrAsFeePayer;
    return await this.provider.signTransaction(
      payload,
      options ? remapTransactionOptions(options) : void 0
    ).catch(remapPetraError);
  }
  async onNetworkChange(callback) {
    var _a;
    (_a = this.provider) == null ? void 0 : _a.onNetworkChange(callback);
  }
  async onAccountChange(callback) {
    var _a;
    (_a = this.provider) == null ? void 0 : _a.onAccountChange(callback);
  }
  async network() {
    const response = await window.petra.getNetwork().catch(remapPetraError);
    return {
      name: response.name,
      chainId: response.chainId,
      url: response.url
    };
  }
};
export {
  PetraWallet,
  PetraWalletName
};
//# sourceMappingURL=petra-plugin-wallet-adapter.js.map
