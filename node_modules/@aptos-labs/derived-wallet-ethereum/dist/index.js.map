{"version":3,"sources":["../src/index.ts","../src/EIP1193DerivedPublicKey.ts","../src/createSiweEnvelope.ts","../src/EIP1193DerivedSignature.ts","../src/EIP1193DerivedWallet.ts","../src/shared.ts","../src/signAptosMessage.ts","../src/signAptosTransaction.ts","../src/setupAutomaticDerivation.ts"],"sourcesContent":["export * from \"./EIP1193DerivedPublicKey\";\nexport * from \"./EIP1193DerivedSignature\";\nexport * from \"./EIP1193DerivedWallet\";\nexport * from \"./setupAutomaticDerivation\";\nexport * from \"./shared\";\n","import { computeDerivableAuthenticationKey, parseAptosSigningMessage } from '@aptos-labs/derived-wallet-base';\nimport {\n  AccountPublicKey,\n  AptosConfig,\n  AuthenticationKey,\n  Deserializer,\n  hashValues,\n  Hex,\n  HexInput,\n  Serializer,\n  Signature,\n  VerifySignatureArgs,\n} from '@aptos-labs/ts-sdk';\nimport { verifyMessage as verifyEthereumMessage } from 'ethers';\nimport {\n  createSiweEnvelopeForAptosStructuredMessage,\n  createSiweEnvelopeForAptosTransaction,\n} from './createSiweEnvelope';\nimport { EIP1193DerivedSignature } from './EIP1193DerivedSignature';\nimport { EthereumAddress } from './shared';\n\nexport interface EIP1193DerivedPublicKeyParams {\n  domain: string;\n  ethereumAddress: EthereumAddress;\n  authenticationFunction: string;\n}\n\nexport class EIP1193DerivedPublicKey extends AccountPublicKey {\n  readonly domain: string;\n  readonly ethereumAddress: EthereumAddress;\n  readonly authenticationFunction: string;\n\n  private readonly _authKey: AuthenticationKey;\n\n  constructor({ domain, ethereumAddress, authenticationFunction }: EIP1193DerivedPublicKeyParams) {\n    super();\n    this.domain = domain;\n    this.ethereumAddress = ethereumAddress;\n    this.authenticationFunction = authenticationFunction;\n\n    const utf8EncodedDomain = new TextEncoder().encode(domain);\n    const ethereumAddressBytes = Hex.fromHexInput(ethereumAddress).toUint8Array();\n\n    const serializer = new Serializer();\n    serializer.serializeBytes(utf8EncodedDomain);\n    serializer.serializeBytes(ethereumAddressBytes);\n    const accountIdentifier = hashValues([serializer.toUint8Array()]);\n\n    this._authKey = computeDerivableAuthenticationKey(\n      authenticationFunction,\n      ethereumAddress,\n      domain\n    );\n  }\n\n  authKey(): AuthenticationKey {\n    return this._authKey;\n  }\n\n  verifySignature({ message, signature }: VerifySignatureArgs): boolean {\n    const parsedSigningMessage = parseAptosSigningMessage(message);\n    if (!parsedSigningMessage || !(signature instanceof EIP1193DerivedSignature)) {\n      return false;\n    }\n\n    const { chainId, issuedAt, siweSignature } = signature;\n    const signingMessageDigest = hashValues([message]);\n\n    // Obtain SIWE envelope for the signing message\n    const envelopeInput = {\n      ethereumAddress: this.ethereumAddress,\n      chainId,\n      signingMessageDigest,\n      issuedAt,\n    };\n\n    const siweMessage = parsedSigningMessage.type === 'structuredMessage'\n      ? createSiweEnvelopeForAptosStructuredMessage({\n        ...parsedSigningMessage,\n        ...envelopeInput,\n      })\n      : createSiweEnvelopeForAptosTransaction({\n        ...parsedSigningMessage,\n        ...envelopeInput,\n      });\n\n    const recoveredAddress = verifyEthereumMessage(siweMessage, siweSignature);\n    return recoveredAddress === this.ethereumAddress;\n  }\n\n  async verifySignatureAsync(args: { aptosConfig: AptosConfig, message: HexInput, signature: Signature }): Promise<boolean> {\n    return this.verifySignature({message: args.message, signature: args.signature});\n  }\n\n  // region Serialization\n\n  serialize(serializer: Serializer) {\n    serializer.serializeStr(this.domain);\n    serializer.serializeFixedBytes(Hex.fromHexInput(this.ethereumAddress).toUint8Array());\n    serializer.serializeStr(this.authenticationFunction);\n  }\n\n  static deserialize(deserializer: Deserializer) {\n    const domain = deserializer.deserializeStr();\n    const ethereumAddressBytes = deserializer.deserializeFixedBytes(20);\n    const ethereumAddress = Hex.fromHexInput(ethereumAddressBytes).toString() as EthereumAddress;\n    const authenticationFunction = deserializer.deserializeStr();\n    return new EIP1193DerivedPublicKey({ domain, ethereumAddress, authenticationFunction });\n  }\n\n  // endregion\n}\n","import {\n  createStructuredMessageStatement,\n  createTransactionStatement,\n  StructuredMessage,\n} from '@aptos-labs/derived-wallet-base';\nimport { AnyRawTransaction, Hex, HexInput } from '@aptos-labs/ts-sdk';\nimport { createSiweMessage } from 'viem/siwe';\nimport { EthereumAddress } from './shared';\n\nexport interface CreateSiweEnvelopeInput {\n  ethereumAddress: EthereumAddress;\n  chainId: number;\n  signingMessageDigest: HexInput;\n  issuedAt: Date;\n}\n\nfunction createSiweEnvelope(input: CreateSiweEnvelopeInput & { statement: string }) {\n  const { ethereumAddress, chainId, signingMessageDigest, issuedAt, statement } = input;\n  const digestHex = Hex.fromHexInput(signingMessageDigest).toString();\n  return createSiweMessage({\n    address: ethereumAddress,\n    domain: window.location.host,\n    uri: window.location.origin,\n    chainId,\n    nonce: digestHex,\n    statement,\n    version: '1',\n    issuedAt,\n  });\n}\n\nexport function createSiweEnvelopeForAptosStructuredMessage(\n  input: CreateSiweEnvelopeInput & { structuredMessage: StructuredMessage },\n) {\n  const { structuredMessage, ...rest } = input;\n  const statement = createStructuredMessageStatement(structuredMessage);\n  return createSiweEnvelope({ ...rest, statement });\n}\n\nexport function createSiweEnvelopeForAptosTransaction(input: CreateSiweEnvelopeInput & {\n  rawTransaction: AnyRawTransaction\n}) {\n  const { rawTransaction, ...rest } = input;\n  const statement = createTransactionStatement(rawTransaction);\n  return createSiweEnvelope({ ...rest, statement });\n\n}\n\n","import { Deserializer, Hex, HexInput, Serializer, Signature } from '@aptos-labs/ts-sdk';\n\nexport class EIP1193DerivedSignature extends Signature {\n  static readonly LENGTH = 65;\n\n  private readonly _siweSignature: Uint8Array;\n  readonly chainId: number;\n  readonly issuedAt: Date;\n\n  constructor(siweSignature: HexInput, chainId: number, issuedAt: Date) {\n    super();\n    this._siweSignature = Hex.fromHexInput(siweSignature).toUint8Array();\n    if (this._siweSignature.length !== EIP1193DerivedSignature.LENGTH) {\n      throw new Error('Expected signature length to be 65 bytes');\n    }\n    this.chainId = chainId;\n    this.issuedAt = issuedAt;\n  }\n\n  get siweSignature() {\n    return Hex.fromHexInput(this._siweSignature).toString();\n  }\n\n  serialize(serializer: Serializer) {\n    serializer.serializeFixedBytes(this._siweSignature);\n    serializer.serializeU32AsUleb128(this.chainId);\n    serializer.serializeU64(this.issuedAt.getTime());\n  }\n\n  static deserialize(deserializer: Deserializer) {\n    const siweSignature = deserializer.deserializeFixedBytes(EIP1193DerivedSignature.LENGTH);\n    const chainId = deserializer.deserializeUleb128AsU32();\n    // Number can safely contain a unix timestamp\n    const issuedAt = new Date(Number(deserializer.deserializeU64()));\n    return new EIP1193DerivedSignature(siweSignature, chainId, issuedAt);\n  }\n}\n","import { fetchDevnetChainId, isNullCallback, mapUserResponse } from '@aptos-labs/derived-wallet-base';\nimport {\n  AccountAuthenticator,\n  AnyRawTransaction,\n  Network,\n  NetworkToChainId,\n  NetworkToNodeAPI,\n} from '@aptos-labs/ts-sdk';\nimport {\n  AccountInfo,\n  APTOS_CHAINS,\n  AptosChangeNetworkOutput,\n  AptosConnectOutput,\n  AptosFeatures,\n  AptosSignMessageInput,\n  AptosSignMessageOutput,\n  AptosWallet,\n  NetworkInfo,\n  UserResponse,\n  UserResponseStatus,\n  WalletIcon,\n} from \"@aptos-labs/wallet-standard\";\nimport { BrowserProvider } from 'ethers';\nimport type { EIP1193Provider, EIP6963ProviderDetail } from 'mipd';\nimport { EIP1193DerivedPublicKey } from './EIP1193DerivedPublicKey';\nimport { EthereumAddress, wrapEthersUserResponse } from './shared';\nimport { signAptosMessageWithEthereum } from './signAptosMessage';\nimport { signAptosTransactionWithEthereum } from './signAptosTransaction';\n\nconst defaultAuthenticationFunction = '0x7::eip1193::authenticate';\n\nexport interface EIP1193DerivedWalletOptions {\n  authenticationFunction?: string;\n  defaultNetwork?: Network;\n}\n\nexport class EIP1193DerivedWallet implements AptosWallet {\n  readonly eip1193Provider: EIP1193Provider;\n  readonly eip1193Ethers: BrowserProvider;\n  readonly domain: string;\n  readonly authenticationFunction: string;\n  defaultNetwork: Network;\n\n  readonly version = \"1.0.0\";\n  readonly name: string;\n  readonly icon: WalletIcon;\n  readonly url: string;\n  readonly accounts = [];\n  readonly chains = APTOS_CHAINS;\n\n  constructor(providerDetail: EIP6963ProviderDetail, options: EIP1193DerivedWalletOptions = {}) {\n    const { info, provider } = providerDetail;\n    const {\n      authenticationFunction = defaultAuthenticationFunction,\n      defaultNetwork = Network.MAINNET,\n    } = options;\n\n    this.eip1193Provider = provider;\n    this.eip1193Ethers = new BrowserProvider(provider);\n\n    this.domain = window.location.origin;\n    this.authenticationFunction = authenticationFunction;\n    this.defaultNetwork = defaultNetwork;\n    this.name = `${info.name} (Ethereum)`;\n    // Phantom's icon is wrapped with new lines :shrug:\n    this.icon = info.icon.trim() as WalletIcon;\n    this.url = info.rdns;\n  }\n\n  readonly features: AptosFeatures = {\n    'aptos:connect': {\n      version: '1.0.0',\n      connect: () => this.connect(),\n    },\n    'aptos:disconnect': {\n      version: '1.0.0',\n      disconnect: () => this.disconnect(),\n    },\n    'aptos:account': {\n      version: '1.0.0',\n      account: () => this.getActiveAccount(),\n    },\n    'aptos:onAccountChange': {\n      version: '1.0.0',\n      onAccountChange: async (callback) => this.onActiveAccountChange(callback),\n    },\n    'aptos:network': {\n      version: '1.0.0',\n      network: () => this.getActiveNetwork(),\n    },\n    'aptos:changeNetwork': {\n      version: '1.0.0',\n      changeNetwork: (newNetwork) => this.changeNetwork(newNetwork),\n    },\n    'aptos:onNetworkChange': {\n      version: '1.0.0',\n      onNetworkChange: async (callback) => this.onActiveNetworkChange(callback),\n    },\n    \"aptos:signMessage\": {\n      version: '1.0.0',\n      signMessage: (args) => this.signMessage(args),\n    },\n    \"aptos:signTransaction\": {\n      version: '1.0.0',\n      signTransaction: (...args) => this.signTransaction(...args),\n    },\n  }\n\n  private derivePublicKey(ethereumAddress: EthereumAddress) {\n    return new EIP1193DerivedPublicKey({\n      domain: this.domain,\n      ethereumAddress,\n      authenticationFunction: this.authenticationFunction,\n    });\n  }\n\n  // region Connection\n\n  async connect(): Promise<UserResponse<AptosConnectOutput>> {\n    const response = await wrapEthersUserResponse(this.eip1193Ethers.getSigner());\n    return mapUserResponse(response, (account) => {\n      const publicKey = this.derivePublicKey(account.address as EthereumAddress);\n      const aptosAddress = publicKey.authKey().derivedAddress();\n      return new AccountInfo({ publicKey, address: aptosAddress });\n    });\n  }\n\n  async disconnect() {\n    // TODO: Eip1193 doesn't provide a \"disconnect\" method, so we have to keep track locally\n  }\n\n  // endregion\n\n  // region Accounts\n\n  async getActiveAccount() {\n    const [activeAccount] = await this.eip1193Ethers.listAccounts();\n    if (!activeAccount) {\n      throw new Error('Account not connected');\n    }\n    const publicKey = this.derivePublicKey(activeAccount.address as EthereumAddress);\n    const aptosAddress = publicKey.authKey().derivedAddress();\n    return new AccountInfo({ publicKey, address: aptosAddress });\n  }\n\n  private onAccountsChangedListeners: ((newAccounts: EthereumAddress[]) => void)[] = []\n\n  onActiveAccountChange(callback: (newAccount: AccountInfo) => void) {\n    if (isNullCallback(callback)) {\n      for (const listener of this.onAccountsChangedListeners) {\n        this.eip1193Provider.removeListener('accountsChanged', listener);\n      }\n      this.onAccountsChangedListeners = [];\n    } else {\n      const listener = ([ethereumAddress]: EthereumAddress[]) => {\n        if (!ethereumAddress) {\n          callback(undefined as any as AccountInfo);\n          return;\n        }\n        const publicKey = this.derivePublicKey(ethereumAddress);\n        const aptosAddress = publicKey.authKey().derivedAddress();\n        const account = new AccountInfo({ publicKey, address: aptosAddress });\n        callback(account);\n      };\n      this.onAccountsChangedListeners.push(listener);\n      this.eip1193Provider.on('accountsChanged', listener);\n    }\n  }\n\n  // endregion\n\n  // region Networks\n\n  private onActiveNetworkChangeListeners: ((newNetwork: NetworkInfo) => void)[] = [];\n\n  async getActiveNetwork(): Promise<NetworkInfo> {\n    const chainId = NetworkToChainId[this.defaultNetwork];\n    const url = NetworkToNodeAPI[this.defaultNetwork];\n    return {\n      name: this.defaultNetwork,\n      chainId,\n      url,\n    };\n  }\n\n  async changeNetwork(newNetwork: NetworkInfo): Promise<UserResponse<AptosChangeNetworkOutput>> {\n    const { name, chainId, url } = newNetwork;\n    if (name === Network.CUSTOM) {\n      throw new Error('Custom network not currently supported');\n    }\n    this.defaultNetwork = name;\n    for (const listener of this.onActiveNetworkChangeListeners) {\n      listener({\n        name,\n        chainId: chainId ?? NetworkToChainId[name],\n        url: url ?? NetworkToNodeAPI[name],\n      });\n    }\n    return {\n      status: UserResponseStatus.APPROVED,\n      args: { success: true },\n    };\n  }\n\n  onActiveNetworkChange(callback: (newNetwork: NetworkInfo) => void) {\n    if (isNullCallback(callback)) {\n      this.onActiveNetworkChangeListeners = [];\n    } else {\n      this.onActiveNetworkChangeListeners.push(callback);\n    }\n  }\n\n  // endregion\n\n  // region Signatures\n\n  async signMessage(input: AptosSignMessageInput): Promise<UserResponse<AptosSignMessageOutput>> {\n    const chainId = this.defaultNetwork === Network.DEVNET ? await fetchDevnetChainId() :NetworkToChainId[this.defaultNetwork];\n    return signAptosMessageWithEthereum({\n      eip1193Provider: this.eip1193Provider,\n      authenticationFunction: this.authenticationFunction,\n      messageInput: {\n        ...input,\n        chainId,\n      },\n    })\n  }\n\n  async signTransaction(\n    rawTransaction: AnyRawTransaction,\n    _asFeePayer?: boolean,\n  ): Promise<UserResponse<AccountAuthenticator>> {\n    return signAptosTransactionWithEthereum({\n      eip1193Provider: this.eip1193Provider,\n      authenticationFunction: this.authenticationFunction,\n      rawTransaction,\n    })\n  }\n\n  // endregion\n}\n","import { makeUserApproval, makeUserRejection } from '@aptos-labs/derived-wallet-base';\nimport { UserResponse } from '@aptos-labs/wallet-standard';\nimport { isError as isEthersError } from 'ethers';\n\nexport type EthereumAddress = `0x${string}`;\n\n/**\n * Adapt EIP1193 response into a UserResponse.\n * `UserRejectedRequestError` will be converted into a rejection.\n */\nexport async function wrapEthersUserResponse<TResponse>(promise: Promise<TResponse>): Promise<UserResponse<TResponse>> {\n  try {\n    const response = await promise;\n    return makeUserApproval(response);\n  } catch (err) {\n    if (isEthersError(err, 'ACTION_REJECTED')) {\n      return makeUserRejection();\n    }\n    throw err;\n  }\n}\n","import {\n  encodeStructuredMessage,\n  mapUserResponse,\n  StructuredMessage,\n  StructuredMessageInput,\n} from '@aptos-labs/derived-wallet-base';\nimport { hashValues } from '@aptos-labs/ts-sdk';\nimport { AptosSignMessageOutput, UserResponse } from \"@aptos-labs/wallet-standard\";\nimport { BrowserProvider, Eip1193Provider } from 'ethers';\nimport { createSiweEnvelopeForAptosStructuredMessage } from './createSiweEnvelope';\nimport { EIP1193DerivedPublicKey } from './EIP1193DerivedPublicKey';\nimport { EIP1193DerivedSignature } from './EIP1193DerivedSignature';\nimport { EthereumAddress, wrapEthersUserResponse } from './shared';\n\nexport interface StructuredMessageInputWithChainId extends StructuredMessageInput {\n  chainId: number;\n}\n\nexport interface SignAptosMessageWithEthereumInput {\n  eip1193Provider: Eip1193Provider | BrowserProvider;\n  ethereumAddress?: EthereumAddress;\n  authenticationFunction: string;\n  messageInput: StructuredMessageInputWithChainId;\n}\n\nexport async function signAptosMessageWithEthereum(input: SignAptosMessageWithEthereumInput): Promise<UserResponse<AptosSignMessageOutput>> {\n  const { authenticationFunction, messageInput } = input;\n  const eip1193Provider = input.eip1193Provider instanceof BrowserProvider\n    ? input.eip1193Provider\n    : new BrowserProvider(input.eip1193Provider);\n\n  const accounts = await eip1193Provider.listAccounts();\n  const ethereumAccount = input.ethereumAddress\n    ? accounts.find((account) => account.address === input.ethereumAddress)\n    : accounts[0];\n  if (!ethereumAccount) {\n    throw new Error('Account not connected');\n  }\n  const ethereumAddress = ethereumAccount.address as EthereumAddress;\n\n\n  const aptosPublicKey = new EIP1193DerivedPublicKey({\n    domain: window.location.origin,\n    ethereumAddress,\n    authenticationFunction,\n  });\n\n  const { message, nonce, chainId, ...flags } = messageInput;\n  const aptosAddress = flags.address ? aptosPublicKey.authKey().derivedAddress() : undefined;\n  const application = flags.application ? window.location.origin : undefined;\n  const structuredMessage: StructuredMessage = {\n    address: aptosAddress?.toString(),\n    application,\n    chainId,\n    message,\n    nonce,\n  };\n\n  const signingMessage = encodeStructuredMessage(structuredMessage);\n  const signingMessageDigest = hashValues([signingMessage]);\n\n  // We need to provide `issuedAt` externally so that we can match it with the signature\n  const issuedAt = new Date();\n  const siweMessage = createSiweEnvelopeForAptosStructuredMessage({\n    ethereumAddress,\n    chainId,\n    structuredMessage,\n    signingMessageDigest,\n    issuedAt,\n  });\n\n  const response = await wrapEthersUserResponse(ethereumAccount.signMessage(siweMessage));\n\n  return mapUserResponse(response, (siweSignature) => {\n    const signature = new EIP1193DerivedSignature(siweSignature, chainId, issuedAt);\n    const fullMessage = new TextDecoder().decode(signingMessage);\n    return {\n      prefix: 'APTOS',\n      fullMessage,\n      message,\n      nonce,\n      signature,\n    };\n  });\n}\n","import { mapUserResponse } from '@aptos-labs/derived-wallet-base';\nimport {\n  AccountAuthenticator,\n  AccountAuthenticatorAbstraction,\n  AnyRawTransaction,\n  generateSigningMessageForTransaction,\n  hashValues,\n} from '@aptos-labs/ts-sdk';\nimport { UserResponse } from \"@aptos-labs/wallet-standard\";\nimport { BrowserProvider, Eip1193Provider } from 'ethers';\nimport { createSiweEnvelopeForAptosTransaction } from './createSiweEnvelope';\nimport { EIP1193DerivedSignature } from './EIP1193DerivedSignature';\nimport { EthereumAddress, wrapEthersUserResponse } from './shared';\n\nexport interface SignAptosTransactionWithEthereumInput {\n  eip1193Provider: Eip1193Provider | BrowserProvider;\n  ethereumAddress?: EthereumAddress;\n  authenticationFunction: string;\n  rawTransaction: AnyRawTransaction;\n}\n\nexport async function signAptosTransactionWithEthereum(input: SignAptosTransactionWithEthereumInput): Promise<UserResponse<AccountAuthenticator>> {\n  const { authenticationFunction, rawTransaction } = input;\n  const eip1193Provider = input.eip1193Provider instanceof BrowserProvider\n    ? input.eip1193Provider\n    : new BrowserProvider(input.eip1193Provider);\n\n  const accounts = await eip1193Provider.listAccounts();\n  const ethereumAccount = input.ethereumAddress\n    ? accounts.find((account) => account.address === input.ethereumAddress)\n    : accounts[0];\n  if (!ethereumAccount) {\n    throw new Error('Account not connected');\n  }\n  const ethereumAddress = ethereumAccount.address as EthereumAddress;\n\n  const signingMessage = generateSigningMessageForTransaction(rawTransaction);\n  const signingMessageDigest = hashValues([signingMessage]);\n\n  const chainId = rawTransaction.rawTransaction.chain_id.chainId;\n\n  // We need to provide `issuedAt` externally so that we can match it with the signature\n  const issuedAt = new Date();\n\n  const siweMessage = createSiweEnvelopeForAptosTransaction({\n    ethereumAddress,\n    chainId,\n    rawTransaction,\n    signingMessageDigest,\n    issuedAt,\n  });\n\n  const response = await wrapEthersUserResponse(ethereumAccount.signMessage(siweMessage));\n\n  return mapUserResponse(response, (siweSignature) => {\n    const signature = new EIP1193DerivedSignature(siweSignature, chainId, issuedAt);\n    const authenticator = signature.bcsToBytes();\n    return new AccountAuthenticatorAbstraction(\n      authenticationFunction,\n      signingMessageDigest,\n      authenticator,\n    );\n  });\n}\n","import { getWallets } from '@wallet-standard/app';\nimport { createStore } from 'mipd';\nimport { EIP6963ProviderDetail } from 'mipd/src/types';\nimport { EIP1193DerivedWallet, EIP1193DerivedWalletOptions } from './EIP1193DerivedWallet';\n\nexport function setupAutomaticEthereumWalletDerivation(options: EIP1193DerivedWalletOptions = {}) {\n  const walletsApi = getWallets();\n  const eip6963Store = createStore();\n\n  type UnsubscribeCallback = () => void;\n  let registrations: { [name: string]: UnsubscribeCallback } = {};\n\n  const deriveAndRegisterWallet = (detail: EIP6963ProviderDetail) => {\n    const derivedWallet = new EIP1193DerivedWallet(detail, options);\n    registrations[detail.info.rdns] = walletsApi.register(derivedWallet);\n  };\n\n  const initialProviders = eip6963Store.getProviders();\n  for (const detail of initialProviders) {\n    deriveAndRegisterWallet(detail);\n  }\n\n  eip6963Store.subscribe((details) => {\n    for (const detail of details) {\n      deriveAndRegisterWallet(detail);\n    }\n  });\n\n  return () => {\n    eip6963Store.destroy();\n    for (const unregisterWallet of Object.values(registrations)) {\n      unregisterWallet();\n    }\n  };\n}\n"],"mappings":"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","names":["import_derived_wallet_base","import_ts_sdk","import_ts_sdk","verifyEthereumMessage","import_derived_wallet_base","import_ts_sdk","import_ethers","import_derived_wallet_base","import_ethers","isEthersError","import_derived_wallet_base","import_ts_sdk","import_ethers","import_derived_wallet_base","import_ts_sdk","import_ethers"]}