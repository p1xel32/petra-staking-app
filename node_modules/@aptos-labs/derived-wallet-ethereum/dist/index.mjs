// src/EIP1193DerivedPublicKey.ts
import {
  computeDerivableAuthenticationKey,
  encodeStructuredMessage,
  parseAptosSigningMessage
} from "@aptos-labs/derived-wallet-base";
import {
  AccountPublicKey,
  hashValues,
  Hex as Hex3
} from "@aptos-labs/ts-sdk";
import { verifyMessage as verifyEthereumMessage } from "ethers";

// src/createSiweEnvelope.ts
import {
  createStructuredMessageStatement,
  createTransactionStatement
} from "@aptos-labs/derived-wallet-base";
import { Hex } from "@aptos-labs/ts-sdk";
import { createSiweMessage } from "viem/siwe";
function createSiweEnvelope(input) {
  const {
    ethereumAddress,
    chainId,
    signingMessageDigest,
    issuedAt,
    statement
  } = input;
  const digestHex = Hex.fromHexInput(signingMessageDigest).toString();
  return createSiweMessage({
    address: ethereumAddress,
    domain: window.location.host,
    uri: window.location.origin,
    chainId,
    nonce: digestHex,
    statement,
    version: "1",
    issuedAt
  });
}
function createSiweEnvelopeForAptosTransaction(input) {
  const { rawTransaction, ...rest } = input;
  const statement = createTransactionStatement(rawTransaction);
  return createSiweEnvelope({ ...rest, statement });
}

// src/EIP1193DerivedSignature.ts
import {
  Hex as Hex2,
  Signature
} from "@aptos-labs/ts-sdk";
var _EIP1193PersonalSignature = class _EIP1193PersonalSignature extends Signature {
  constructor(siweSignature) {
    super();
    this._siweSignature = Hex2.fromHexInput(siweSignature).toUint8Array();
  }
  get siweSignature() {
    return Hex2.fromHexInput(this._siweSignature).toString();
  }
  serialize(serializer) {
    serializer.serializeBytes(this._siweSignature);
  }
  static deserialize(deserializer) {
    const signature = deserializer.deserializeBytes();
    return new _EIP1193PersonalSignature(signature);
  }
};
_EIP1193PersonalSignature.LENGTH = 65;
var EIP1193PersonalSignature = _EIP1193PersonalSignature;
var EIP1193SiweSignature = class _EIP1193SiweSignature extends EIP1193PersonalSignature {
  constructor(scheme, issuedAt, siweSignature) {
    super(siweSignature);
    this.issuedAt = issuedAt;
    this.scheme = scheme;
  }
  serialize(serializer) {
    serializer.serializeStr(this.scheme);
    serializer.serializeStr(this.issuedAt.toISOString());
    serializer.serializeBytes(this._siweSignature);
  }
  static deserialize(deserializer) {
    const scheme = deserializer.deserializeStr();
    const issuedAt = new Date(deserializer.deserializeStr());
    const siweSignature = deserializer.deserializeBytes();
    return new _EIP1193SiweSignature(scheme, issuedAt, siweSignature);
  }
};

// src/EIP1193DerivedPublicKey.ts
var EIP1193DerivedPublicKey = class _EIP1193DerivedPublicKey extends AccountPublicKey {
  constructor({
    domain,
    ethereumAddress,
    authenticationFunction
  }) {
    super();
    this.domain = domain;
    this.ethereumAddress = ethereumAddress;
    this.authenticationFunction = authenticationFunction;
    this._authKey = computeDerivableAuthenticationKey(
      authenticationFunction,
      ethereumAddress,
      domain
    );
  }
  authKey() {
    return this._authKey;
  }
  verifySignature({ message, signature }) {
    const parsedSigningMessage = parseAptosSigningMessage(message);
    if (!parsedSigningMessage) {
      return false;
    }
    let messageBytes;
    if (parsedSigningMessage.type === "structuredMessage") {
      if (!(signature instanceof EIP1193PersonalSignature)) return false;
      messageBytes = encodeStructuredMessage(
        parsedSigningMessage.structuredMessage
      );
    } else {
      if (!(signature instanceof EIP1193SiweSignature)) return false;
      const { issuedAt } = signature;
      const signingMessageDigest = hashValues([message]);
      const envelopeInput = {
        ethereumAddress: this.ethereumAddress,
        signingMessageDigest,
        issuedAt
      };
      messageBytes = createSiweEnvelopeForAptosTransaction({
        ...parsedSigningMessage,
        ...envelopeInput,
        chainId: parsedSigningMessage.rawTransaction.rawTransaction.chain_id.chainId
      });
    }
    const { siweSignature } = signature;
    const recoveredAddress = verifyEthereumMessage(messageBytes, siweSignature);
    return recoveredAddress === this.ethereumAddress;
  }
  async verifySignatureAsync(args) {
    return this.verifySignature({
      message: args.message,
      signature: args.signature
    });
  }
  // region Serialization
  serialize(serializer) {
    serializer.serializeStr(this.domain);
    serializer.serializeFixedBytes(
      Hex3.fromHexInput(this.ethereumAddress).toUint8Array()
    );
    serializer.serializeStr(this.authenticationFunction);
  }
  static deserialize(deserializer) {
    const domain = deserializer.deserializeStr();
    const ethereumAddressBytes = deserializer.deserializeFixedBytes(20);
    const ethereumAddress = Hex3.fromHexInput(
      ethereumAddressBytes
    ).toString();
    const authenticationFunction = deserializer.deserializeStr();
    return new _EIP1193DerivedPublicKey({
      domain,
      ethereumAddress,
      authenticationFunction
    });
  }
  // endregion
};

// src/EIP1193DerivedWallet.ts
import {
  fetchDevnetChainId,
  isNullCallback,
  mapUserResponse as mapUserResponse3
} from "@aptos-labs/derived-wallet-base";
import {
  Network,
  NetworkToChainId,
  NetworkToNodeAPI
} from "@aptos-labs/ts-sdk";
import {
  AccountInfo,
  APTOS_CHAINS,
  UserResponseStatus
} from "@aptos-labs/wallet-standard";
import { BrowserProvider as BrowserProvider3 } from "ethers";

// src/shared.ts
import {
  makeUserApproval,
  makeUserRejection
} from "@aptos-labs/derived-wallet-base";
import { isError as isEthersError } from "ethers";
async function wrapEthersUserResponse(promise) {
  try {
    const response = await promise;
    return makeUserApproval(response);
  } catch (err) {
    if (isEthersError(err, "ACTION_REJECTED")) {
      return makeUserRejection();
    }
    throw err;
  }
}

// src/signAptosMessage.ts
import {
  encodeStructuredMessage as encodeStructuredMessage2,
  mapUserResponse
} from "@aptos-labs/derived-wallet-base";
import { BrowserProvider } from "ethers";
async function signAptosMessageWithEthereum(input) {
  const { authenticationFunction, messageInput } = input;
  const eip1193Provider = input.eip1193Provider instanceof BrowserProvider ? input.eip1193Provider : new BrowserProvider(input.eip1193Provider);
  const accounts = await eip1193Provider.listAccounts();
  const ethereumAccount = input.ethereumAddress ? accounts.find((account) => account.address === input.ethereumAddress) : accounts[0];
  if (!ethereumAccount) {
    throw new Error("Account not connected");
  }
  const ethereumAddress = ethereumAccount.address;
  const aptosPublicKey = new EIP1193DerivedPublicKey({
    domain: window.location.origin,
    ethereumAddress,
    authenticationFunction
  });
  const { message, nonce, chainId, ...flags } = messageInput;
  const aptosAddress = flags.address ? aptosPublicKey.authKey().derivedAddress() : void 0;
  const application = flags.application ? window.location.origin : void 0;
  const structuredMessage = {
    address: aptosAddress?.toString(),
    application,
    chainId,
    message,
    nonce
  };
  const signingMessage = encodeStructuredMessage2(structuredMessage);
  const response = await wrapEthersUserResponse(
    ethereumAccount.signMessage(signingMessage)
  );
  return mapUserResponse(response, (siweSignature) => {
    const signature = new EIP1193PersonalSignature(siweSignature);
    const fullMessage = new TextDecoder().decode(signingMessage);
    return {
      prefix: "APTOS",
      fullMessage,
      message,
      nonce,
      signature
    };
  });
}

// src/signAptosTransaction.ts
import {
  DerivableAbstractPublicKey,
  mapUserResponse as mapUserResponse2
} from "@aptos-labs/derived-wallet-base";
import {
  AccountAuthenticatorAbstraction,
  generateSigningMessageForTransaction,
  hashValues as hashValues2,
  Serializer as Serializer3
} from "@aptos-labs/ts-sdk";
import { BrowserProvider as BrowserProvider2 } from "ethers";
var SIGNATURE_TYPE = 1;
async function signAptosTransactionWithEthereum(input) {
  const { authenticationFunction, rawTransaction } = input;
  const eip1193Provider = input.eip1193Provider instanceof BrowserProvider2 ? input.eip1193Provider : new BrowserProvider2(input.eip1193Provider);
  const accounts = await eip1193Provider.listAccounts();
  const ethereumAccount = input.ethereumAddress ? accounts.find((account) => account.address === input.ethereumAddress) : accounts[0];
  if (!ethereumAccount) {
    throw new Error("Account not connected");
  }
  const ethereumAddress = ethereumAccount.address;
  const signingMessage = generateSigningMessageForTransaction(rawTransaction);
  const signingMessageDigest = hashValues2([signingMessage]);
  const chainId = rawTransaction.rawTransaction.chain_id.chainId;
  const issuedAt = /* @__PURE__ */ new Date();
  const siweMessage = createSiweEnvelopeForAptosTransaction({
    ethereumAddress,
    chainId,
    rawTransaction,
    signingMessageDigest,
    issuedAt
  });
  const response = await wrapEthersUserResponse(
    ethereumAccount.signMessage(siweMessage)
  );
  return mapUserResponse2(response, (siweSignature) => {
    const serializer = new Serializer3();
    serializer.serializeU8(SIGNATURE_TYPE);
    const scheme = window.location.protocol.slice(0, -1);
    const signature = new EIP1193SiweSignature(scheme, issuedAt, siweSignature);
    signature.serialize(serializer);
    const abstractSignature = serializer.toUint8Array();
    const abstractPublicKey = new DerivableAbstractPublicKey(
      ethereumAddress,
      window.location.host
    );
    return new AccountAuthenticatorAbstraction(
      authenticationFunction,
      signingMessageDigest,
      abstractSignature,
      abstractPublicKey.bcsToBytes()
    );
  });
}

// src/EIP1193DerivedWallet.ts
var defaultAuthenticationFunction = "0x1::ethereum_derivable_account::authenticate";
var EIP1193DerivedWallet = class {
  constructor(providerDetail, options = {}) {
    this.version = "1.0.0";
    this.accounts = [];
    this.chains = APTOS_CHAINS;
    this.features = {
      "aptos:connect": {
        version: "1.0.0",
        connect: () => this.connect()
      },
      "aptos:disconnect": {
        version: "1.0.0",
        disconnect: () => this.disconnect()
      },
      "aptos:account": {
        version: "1.0.0",
        account: () => this.getActiveAccount()
      },
      "aptos:onAccountChange": {
        version: "1.0.0",
        onAccountChange: async (callback) => this.onActiveAccountChange(callback)
      },
      "aptos:network": {
        version: "1.0.0",
        network: () => this.getActiveNetwork()
      },
      "aptos:changeNetwork": {
        version: "1.0.0",
        changeNetwork: (newNetwork) => this.changeNetwork(newNetwork)
      },
      "aptos:onNetworkChange": {
        version: "1.0.0",
        onNetworkChange: async (callback) => this.onActiveNetworkChange(callback)
      },
      "aptos:signMessage": {
        version: "1.0.0",
        signMessage: (args) => this.signMessage(args)
      },
      "aptos:signTransaction": {
        version: "1.0.0",
        signTransaction: (...args) => this.signTransaction(...args)
      }
    };
    this.onAccountsChangedListeners = [];
    // endregion
    // region Networks
    this.onActiveNetworkChangeListeners = [];
    const { info, provider } = providerDetail;
    const {
      authenticationFunction = defaultAuthenticationFunction,
      defaultNetwork = Network.MAINNET
    } = options;
    this.eip1193Provider = provider;
    this.eip1193Ethers = new BrowserProvider3(provider);
    this.domain = window.location.host;
    this.authenticationFunction = authenticationFunction;
    this.defaultNetwork = defaultNetwork;
    this.name = `${info.name} (Ethereum)`;
    this.icon = info.icon.trim();
    this.url = info.rdns;
  }
  derivePublicKey(ethereumAddress) {
    return new EIP1193DerivedPublicKey({
      domain: this.domain,
      ethereumAddress,
      authenticationFunction: this.authenticationFunction
    });
  }
  // region Connection
  async connect() {
    const response = await wrapEthersUserResponse(
      this.eip1193Ethers.getSigner()
    );
    return mapUserResponse3(response, (account) => {
      const publicKey = this.derivePublicKey(
        account.address
      );
      const aptosAddress = publicKey.authKey().derivedAddress();
      return new AccountInfo({ publicKey, address: aptosAddress });
    });
  }
  async disconnect() {
  }
  // endregion
  // region Accounts
  async getActiveAccount() {
    const [activeAccount] = await this.eip1193Ethers.listAccounts();
    if (!activeAccount) {
      throw new Error("Account not connected");
    }
    const publicKey = this.derivePublicKey(
      activeAccount.address
    );
    const aptosAddress = publicKey.authKey().derivedAddress();
    return new AccountInfo({ publicKey, address: aptosAddress });
  }
  onActiveAccountChange(callback) {
    if (isNullCallback(callback)) {
      for (const listener of this.onAccountsChangedListeners) {
        this.eip1193Provider.removeListener("accountsChanged", listener);
      }
      this.onAccountsChangedListeners = [];
    } else {
      const listener = ([ethereumAddress]) => {
        if (!ethereumAddress) {
          callback(void 0);
          return;
        }
        const publicKey = this.derivePublicKey(ethereumAddress);
        const aptosAddress = publicKey.authKey().derivedAddress();
        const account = new AccountInfo({ publicKey, address: aptosAddress });
        callback(account);
      };
      this.onAccountsChangedListeners.push(listener);
      this.eip1193Provider.on("accountsChanged", listener);
    }
  }
  async getActiveNetwork() {
    const chainId = NetworkToChainId[this.defaultNetwork];
    const url = NetworkToNodeAPI[this.defaultNetwork];
    return {
      name: this.defaultNetwork,
      chainId,
      url
    };
  }
  async changeNetwork(newNetwork) {
    const { name, chainId, url } = newNetwork;
    if (name === Network.CUSTOM) {
      throw new Error("Custom network not currently supported");
    }
    this.defaultNetwork = name;
    for (const listener of this.onActiveNetworkChangeListeners) {
      listener({
        name,
        chainId: chainId ?? NetworkToChainId[name],
        url: url ?? NetworkToNodeAPI[name]
      });
    }
    return {
      status: UserResponseStatus.APPROVED,
      args: { success: true }
    };
  }
  onActiveNetworkChange(callback) {
    if (isNullCallback(callback)) {
      this.onActiveNetworkChangeListeners = [];
    } else {
      this.onActiveNetworkChangeListeners.push(callback);
    }
  }
  // endregion
  // region Signatures
  async signMessage(input) {
    const chainId = input.chainId ? this.defaultNetwork === Network.DEVNET ? await fetchDevnetChainId() : NetworkToChainId[this.defaultNetwork] : void 0;
    return signAptosMessageWithEthereum({
      eip1193Provider: this.eip1193Provider,
      authenticationFunction: this.authenticationFunction,
      messageInput: {
        ...input,
        chainId
      }
    });
  }
  async signTransaction(rawTransaction, _asFeePayer) {
    return signAptosTransactionWithEthereum({
      eip1193Provider: this.eip1193Provider,
      authenticationFunction: this.authenticationFunction,
      rawTransaction
    });
  }
  // endregion
};

// src/setupAutomaticDerivation.ts
import { getWallets } from "@wallet-standard/app";
import { createStore } from "mipd";
function setupAutomaticEthereumWalletDerivation(options = {}) {
  const walletsApi = getWallets();
  const eip6963Store = createStore();
  let registrations = {};
  const deriveAndRegisterWallet = (detail) => {
    const derivedWallet = new EIP1193DerivedWallet(detail, options);
    registrations[detail.info.rdns] = walletsApi.register(derivedWallet);
  };
  const initialProviders = eip6963Store.getProviders();
  for (const detail of initialProviders) {
    deriveAndRegisterWallet(detail);
  }
  eip6963Store.subscribe((details) => {
    for (const detail of details) {
      deriveAndRegisterWallet(detail);
    }
  });
  return () => {
    eip6963Store.destroy();
    for (const unregisterWallet of Object.values(registrations)) {
      unregisterWallet();
    }
  };
}
export {
  EIP1193DerivedPublicKey,
  EIP1193DerivedWallet,
  EIP1193PersonalSignature,
  EIP1193SiweSignature,
  setupAutomaticEthereumWalletDerivation,
  wrapEthersUserResponse
};
//# sourceMappingURL=index.mjs.map