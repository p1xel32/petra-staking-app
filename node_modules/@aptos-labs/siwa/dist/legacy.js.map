{"version":3,"sources":["../src/legacy.ts","../src/core.ts"],"sourcesContent":["import { Hex, type PublicKey, type Signature } from \"@aptos-labs/ts-sdk\";\nimport type {\n  AptosSignInInput,\n  AptosSignInRequiredFields,\n} from \"@aptos-labs/wallet-standard\";\nimport { sha3_256 } from \"@noble/hashes/sha3\";\nimport { createSignInMessageText } from \"./core.js\";\nimport type { VerificationError } from \"./types.js\";\n\nexport type VerificationFullMessageError = \"invalid_full_message\";\n\ntype LegacyVerificationError = VerificationError | VerificationFullMessageError;\n\nexport type LegacyVerificationResult<T> =\n  | { valid: true; data: T }\n  | { valid: false; errors: LegacyVerificationError[] };\n\nexport const createLegacySignInMessage = (\n  input: AptosSignInInput & AptosSignInRequiredFields,\n) => {\n  let message = createSignInMessageText(input);\n  message += `\\n\\nHash: ${Hex.fromHexInput(sha3_256(message)).toString()}`;\n  return message;\n};\n\nexport const verifyLegacySignIn = (\n  input: AptosSignInInput & AptosSignInRequiredFields,\n  output: { publicKey: PublicKey; signature: Signature; message: string },\n): LegacyVerificationResult<AptosSignInInput & AptosSignInRequiredFields> => {\n  const embeddedMessage = createLegacySignInMessage(input);\n\n  if (!output.message.includes(embeddedMessage)) {\n    return { valid: false, errors: [\"invalid_full_message\"] };\n  }\n\n  const isSignatureValid = output.publicKey.verifySignature(output);\n  if (!isSignatureValid) return { valid: false, errors: [\"invalid_signature\"] };\n\n  return { valid: true, data: input };\n};\n","import type { PublicKey, Signature } from \"@aptos-labs/ts-sdk\";\nimport type {\n  AptosSignInInput,\n  AptosSignInRequiredFields,\n} from \"@aptos-labs/wallet-standard\";\nimport { sha3_256 } from \"@noble/hashes/sha3\";\nimport { arraysEqual } from \"./internal.js\";\nimport type {\n  VerificationComparisonError,\n  VerificationMessageError,\n  VerificationResult,\n} from \"./types.js\";\n\n/**\n * Create a SignIn message text from the input following the ABNF format defined in the Sign in with Aptos\n * specifications.\n *\n * @param input The input to create the SignIn message text from.\n *\n * @returns The SignIn message text.\n */\nexport function createSignInMessageText(\n  input: AptosSignInInput & AptosSignInRequiredFields,\n): string {\n  let message = `${input.domain} wants you to sign in with your Aptos account:\\n`;\n  message += `${input.address}`;\n\n  if (input.statement) {\n    message += `\\n\\n${input.statement}`;\n  }\n\n  const fields: string[] = [];\n  if (input.uri) {\n    fields.push(`URI: ${input.uri}`);\n  }\n  if (input.version) {\n    fields.push(`Version: ${input.version}`);\n  }\n  if (input.nonce) {\n    fields.push(`Nonce: ${input.nonce}`);\n  }\n  if (input.issuedAt) {\n    fields.push(`Issued At: ${input.issuedAt}`);\n  }\n  if (input.expirationTime) {\n    fields.push(`Expiration Time: ${input.expirationTime}`);\n  }\n  if (input.notBefore) {\n    fields.push(`Not Before: ${input.notBefore}`);\n  }\n  if (input.requestId) {\n    fields.push(`Request ID: ${input.requestId}`);\n  }\n  if (input.chainId) {\n    fields.push(`Chain ID: ${input.chainId}`);\n  }\n  if (input.resources) {\n    fields.push(\"Resources:\");\n    for (const resource of input.resources) {\n      fields.push(`- ${resource}`);\n    }\n  }\n\n  if (fields.length) {\n    message += `\\n\\n${fields.join(\"\\n\")}`;\n  }\n\n  return message;\n}\n\nconst DOMAIN =\n  \"(?<domain>[^\\\\n]+?) wants you to sign in with your Aptos account:\\\\n\";\nconst ADDRESS = \"(?<address>[^\\\\n]+)(?:\\\\n|$)\";\nconst STATEMENT = \"(?:\\\\n(?<statement>[\\\\S\\\\s]*?)(?:\\\\n|$))??\";\nconst URI = \"(?:\\\\nURI: (?<uri>[^\\\\n]+))?\";\nconst VERSION = \"(?:\\\\nVersion: (?<version>[^\\\\n]+))?\";\nconst NONCE = \"(?:\\\\nNonce: (?<nonce>[^\\\\n]+))?\";\nconst ISSUED_AT = \"(?:\\\\nIssued At: (?<issuedAt>[^\\\\n]+))?\";\nconst EXPIRATION_TIME = \"(?:\\\\nExpiration Time: (?<expirationTime>[^\\\\n]+))?\";\nconst NOT_BEFORE = \"(?:\\\\nNot Before: (?<notBefore>[^\\\\n]+))?\";\nconst REQUEST_ID = \"(?:\\\\nRequest ID: (?<requestId>[^\\\\n]+))?\";\nconst CHAIN_ID = \"(?:\\\\nChain ID: (?<chainId>[^\\\\n]+))?\";\nconst RESOURCES = \"(?:\\\\nResources:(?<resources>(?:\\\\n- [^\\\\n]+)*))?\";\nconst FIELDS = `${URI}${VERSION}${NONCE}${ISSUED_AT}${EXPIRATION_TIME}${NOT_BEFORE}${REQUEST_ID}${CHAIN_ID}${RESOURCES}`;\nconst MESSAGE = new RegExp(`^${DOMAIN}${ADDRESS}${STATEMENT}${FIELDS}\\\\n*$`);\n\nexport function parseSignInMessageText(\n  text: string,\n): VerificationResult<AptosSignInInput & AptosSignInRequiredFields> {\n  const match = MESSAGE.exec(text);\n  if (!match) return { valid: false, errors: [\"invalid_message\"] };\n\n  const groups = match.groups;\n  if (!groups) return { valid: false, errors: [\"invalid_message\"] };\n\n  const errors: VerificationMessageError[] = [];\n\n  if (!groups.domain || groups.domain === \"undefined\")\n    errors.push(\"message_domain_missing\");\n  if (!groups.address || groups.address === \"undefined\")\n    errors.push(\"message_address_missing\");\n  if (!groups.version || groups.version === \"undefined\")\n    errors.push(\"message_version_missing\");\n  if (!groups.chainId || groups.chainId === \"undefined\")\n    errors.push(\"message_chain_id_missing\");\n\n  if (errors.length) return { valid: false, errors };\n\n  return {\n    valid: true,\n    data: {\n      domain: groups.domain,\n      address: groups.address,\n      statement: groups.statement,\n      uri: groups.uri,\n      version: groups.version,\n      nonce: groups.nonce,\n      chainId: groups.chainId,\n      issuedAt: groups.issuedAt,\n      expirationTime: groups.expirationTime,\n      notBefore: groups.notBefore,\n      requestId: groups.requestId,\n      resources: groups.resources?.split(\"\\n- \").slice(1),\n    },\n  };\n}\n\n/**\n * Verifies an input SignIn message against expected fields.\n *\n * @param input The input to verify the message against.\n * @param expected The expected message to verify against the input.\n *\n * @returns The verification result.\n */\nexport function verifySignInMessage(\n  input: AptosSignInInput,\n  expected: string,\n  options?: { excludedResources?: string[] },\n): VerificationResult<AptosSignInInput & AptosSignInRequiredFields> {\n  const parsedFields = parseSignInMessageText(expected);\n  if (!parsedFields.valid) return parsedFields;\n\n  const errors: VerificationComparisonError[] = [];\n\n  if (input.address && input.address !== parsedFields.data.address)\n    errors.push(\"message_address_mismatch\");\n  if (input.statement !== parsedFields.data.statement)\n    errors.push(\"message_statement_mismatch\");\n  if (input.uri && input.uri !== parsedFields.data.uri)\n    errors.push(\"message_uri_mismatch\");\n  if (input.version && input.version !== parsedFields.data.version)\n    errors.push(\"message_version_mismatch\");\n  if (input.chainId && input.chainId !== parsedFields.data.chainId)\n    errors.push(\"message_chain_id_mismatch\");\n  if (input.nonce !== parsedFields.data.nonce)\n    errors.push(\"message_nonce_mismatch\");\n  if (input.issuedAt !== parsedFields.data.issuedAt)\n    errors.push(\"message_issued_at_mismatch\");\n  if (input.expirationTime !== parsedFields.data.expirationTime)\n    errors.push(\"message_expiration_time_mismatch\");\n  if (input.notBefore !== parsedFields.data.notBefore)\n    errors.push(\"message_not_before_mismatch\");\n  if (input.requestId !== parsedFields.data.requestId)\n    errors.push(\"message_request_id_mismatch\");\n\n  // If the domain is unexpectedly provided, it must be verified.\n  if (\n    // biome-ignore lint/suspicious/noExplicitAny: May be present in the input.\n    (input as any).domain &&\n    // biome-ignore lint/suspicious/noExplicitAny: May be present in the input.\n    (input as any).domain !== parsedFields.data.domain\n  )\n    errors.push(\"message_domain_mismatch\");\n\n  if (input.resources) {\n    if (!parsedFields.data.resources) {\n      errors.push(\"message_resources_missing\");\n    } else if (\n      !arraysEqual(\n        input.resources,\n        parsedFields.data.resources,\n        options?.excludedResources,\n      )\n    ) {\n      errors.push(\"message_resources_mismatch\");\n    }\n  } else if (parsedFields.data.resources) {\n    errors.push(\"message_resources_unexpected\");\n  }\n\n  if (errors.length) return { valid: false, errors };\n\n  // TODO: Add time verifications\n\n  return { valid: true, data: parsedFields.data };\n}\n\n/**\n * Verifies outputs from a `signIn` method response against input fields.\n *\n * @param input The input to verify the output against.\n * @param output The output to verify against the input.\n *\n * @returns The verification result.\n */\nexport function verifySignIn(\n  input: AptosSignInInput & { domain: string },\n  output: { publicKey: PublicKey; signature: Signature; message: string },\n  options?: { excludedResources?: string[] },\n): VerificationResult<AptosSignInInput & AptosSignInRequiredFields> {\n  const messageVerification = verifySignInMessage(\n    input,\n    output.message,\n    options,\n  );\n  if (!messageVerification.valid) return messageVerification;\n\n  const isSignatureValid = output.publicKey.verifySignature({\n    message: generateSignInSigningMessage(output.message),\n    signature: output.signature,\n  });\n  if (!isSignatureValid) return { valid: false, errors: [\"invalid_signature\"] };\n\n  return { valid: true, data: messageVerification.data };\n}\n\n/**\n * Generate a signing message using the Sign in with Aptos signing algorithm.\n * sha3_256( sha3_256(b\"SIGN_IN_WITH_APTOS::\" ) || <message> )\n *\n * @param message The SIWA message to sign.\n *\n * @returns The signing message.\n */\nexport function generateSignInSigningMessage(message: string): Uint8Array {\n  const domainSeparator = \"SIGN_IN_WITH_APTOS::\";\n  const domainSeparatorHash = sha3_256(domainSeparator);\n  return new Uint8Array([\n    ...domainSeparatorHash,\n    ...new TextEncoder().encode(message),\n  ]);\n}\n"],"mappings":"AAAA,OAAS,OAAAA,MAA2C,qBAKpD,OAAS,YAAAC,MAAgB,qBCAzB,OAAS,YAAAC,MAAgB,qBAgBlB,SAASC,EACdC,EACQ,CACR,IAAIC,EAAU,GAAGD,EAAM,MAAM;AAAA,EAC7BC,GAAW,GAAGD,EAAM,OAAO,GAEvBA,EAAM,YACRC,GAAW;AAAA;AAAA,EAAOD,EAAM,SAAS,IAGnC,IAAME,EAAmB,CAAC,EAyB1B,GAxBIF,EAAM,KACRE,EAAO,KAAK,QAAQF,EAAM,GAAG,EAAE,EAE7BA,EAAM,SACRE,EAAO,KAAK,YAAYF,EAAM,OAAO,EAAE,EAErCA,EAAM,OACRE,EAAO,KAAK,UAAUF,EAAM,KAAK,EAAE,EAEjCA,EAAM,UACRE,EAAO,KAAK,cAAcF,EAAM,QAAQ,EAAE,EAExCA,EAAM,gBACRE,EAAO,KAAK,oBAAoBF,EAAM,cAAc,EAAE,EAEpDA,EAAM,WACRE,EAAO,KAAK,eAAeF,EAAM,SAAS,EAAE,EAE1CA,EAAM,WACRE,EAAO,KAAK,eAAeF,EAAM,SAAS,EAAE,EAE1CA,EAAM,SACRE,EAAO,KAAK,aAAaF,EAAM,OAAO,EAAE,EAEtCA,EAAM,UAAW,CACnBE,EAAO,KAAK,YAAY,EACxB,QAAWC,KAAYH,EAAM,UAC3BE,EAAO,KAAK,KAAKC,CAAQ,EAAE,CAE/B,CAEA,OAAID,EAAO,SACTD,GAAW;AAAA;AAAA,EAAOC,EAAO,KAAK;AAAA,CAAI,CAAC,IAG9BD,CACT,CAEA,IAAMG,EACJ,uEACIC,EAAU,+BACVC,EAAY,6CACZC,EAAM,+BACNC,EAAU,uCACVC,EAAQ,mCACRC,EAAY,0CACZC,EAAkB,sDAClBC,EAAa,4CACbC,EAAa,4CACbC,EAAW,wCACXC,EAAY,oDACZC,EAAS,GAAGT,CAAG,GAAGC,CAAO,GAAGC,CAAK,GAAGC,CAAS,GAAGC,CAAe,GAAGC,CAAU,GAAGC,CAAU,GAAGC,CAAQ,GAAGC,CAAS,GAChHE,EAAU,IAAI,OAAO,IAAIb,CAAM,GAAGC,CAAO,GAAGC,CAAS,GAAGU,CAAM,OAAO,EDnEpE,IAAME,EACXC,GACG,CACH,IAAIC,EAAUC,EAAwBF,CAAK,EAC3C,OAAAC,GAAW;AAAA;AAAA,QAAaE,EAAI,aAAaC,EAASH,CAAO,CAAC,EAAE,SAAS,CAAC,GAC/DA,CACT,EAEaI,EAAqB,CAChCL,EACAM,IAC2E,CAC3E,IAAMC,EAAkBR,EAA0BC,CAAK,EAEvD,OAAKM,EAAO,QAAQ,SAASC,CAAe,EAInBD,EAAO,UAAU,gBAAgBA,CAAM,EAGzD,CAAE,MAAO,GAAM,KAAMN,CAAM,EAFJ,CAAE,MAAO,GAAO,OAAQ,CAAC,mBAAmB,CAAE,EAJnE,CAAE,MAAO,GAAO,OAAQ,CAAC,sBAAsB,CAAE,CAO5D","names":["Hex","sha3_256","sha3_256","createSignInMessageText","input","message","fields","resource","DOMAIN","ADDRESS","STATEMENT","URI","VERSION","NONCE","ISSUED_AT","EXPIRATION_TIME","NOT_BEFORE","REQUEST_ID","CHAIN_ID","RESOURCES","FIELDS","MESSAGE","createLegacySignInMessage","input","message","createSignInMessageText","Hex","sha3_256","verifyLegacySignIn","output","embeddedMessage"]}