{"version":3,"sources":["../src/abstraction.ts","../src/envelope.ts","../src/parseAptosSigningMessage.ts","../src/StructuredMessage.ts","../src/UserResponse.ts","../src/utils.ts"],"sourcesContent":["import {\n  AccountAddress,\n  AuthenticationKey,\n  Deserializer,\n  hashValues,\n  isValidFunctionInfo,\n  Serializable,\n  Serializer,\n} from \"@aptos-labs/ts-sdk\";\n\n/**\n * The domain separator used to calculate the DAA account address.\n */\nexport const ADDRESS_DOMAIN_SEPARATOR = 5;\n\n/**\n * @param functionInfo - The authentication function\n * @param identity - The account identity. Typically it is the wallet public key or account address\n * @param domain - The dapp domain\n * @returns The account address authentication key\n */\nexport function computeDerivableAuthenticationKey(\n  functionInfo: string,\n  identity: string,\n  domain: string\n): AuthenticationKey {\n  try {\n    // TODO: move it to the ts-sdk as the general computation function once we are finalized on the on-chain auth function\n    if (!isValidFunctionInfo(functionInfo)) {\n      throw new Error(`Invalid authentication function ${functionInfo}`);\n    }\n    const [moduleAddress, moduleName, functionName] = functionInfo.split(\"::\");\n\n    // Serialize and append the function info\n    const serializer = new Serializer();\n    AccountAddress.fromString(moduleAddress).serialize(serializer);\n    serializer.serializeStr(moduleName);\n    serializer.serializeStr(functionName);\n\n    // Serialize and append the abstract public key\n    const s2 = new Serializer();\n    const abstractPublicKey = new DerivableAbstractPublicKey(identity, domain);\n    s2.serializeBytes(abstractPublicKey.bcsToBytes());\n\n    // Append the domain separator\n    const domainSeparator = new Uint8Array([ADDRESS_DOMAIN_SEPARATOR]);\n\n    const data = hashValues([\n      serializer.toUint8Array(),\n      s2.toUint8Array(),\n      domainSeparator,\n    ]);\n\n    return new AuthenticationKey({ data });\n  } catch (e) {\n    throw `Error computing domain authentication key: ${e}`;\n  }\n}\n\n/**\n * The derivable abstract public key of the DAA account.\n * \n * @param identity - The identity of the account. Typically it is the wallet public key or account address\n * @param domain - The dapp domain\n */\nexport class DerivableAbstractPublicKey extends Serializable {\n  constructor(\n    public identity: string,\n    public domain: string\n  ) {\n    super();\n  }\n\n  serialize(serializer: Serializer): void {\n    serializer.serializeStr(this.identity);\n    serializer.serializeStr(this.domain);\n  }\n\n  static deserialize(deserializer: Deserializer): DerivableAbstractPublicKey {\n    const identity = deserializer.deserializeStr();\n    const domain = deserializer.deserializeStr();\n    return new DerivableAbstractPublicKey(identity, domain);\n  }\n}\n","import {\n  AnyRawTransaction,\n  NetworkToChainId,\n  TransactionPayload,\n  TransactionPayloadEntryFunction,\n} from '@aptos-labs/ts-sdk';\nimport { StructuredMessage } from './StructuredMessage';\n\n/**\n * Attempt to convert the specified chainId into a human-readable identifier.\n */\nfunction getChainName(chainId: number) {\n  // Obtain the network name if available\n  for (const [network, otherChainId] of Object.entries(NetworkToChainId)) {\n    if (otherChainId === chainId) {\n      return network;\n    }\n  }\n  // Otherwise return a chain id descriptor\n  return `custom network: ${chainId}`;\n}\n\n/**\n * Extract the fully-qualified entry function name from the transaction payload, when applicable\n */\nexport function getEntryFunctionName(payload: TransactionPayload) {\n  if (!(payload instanceof TransactionPayloadEntryFunction)) {\n    return undefined;\n  }\n  const moduleAddress = payload.entryFunction.module_name.address.toString();\n  const moduleName = payload.entryFunction.module_name.name.identifier;\n  const functionName = payload.entryFunction.function_name.identifier;\n  return `${moduleAddress}::${moduleName}::${functionName}`;\n}\n\n/**\n * Create a human-readable statement for the specified Aptos message,\n * suitable to be included into a \"Sign in with ...\" envelope\n */\nexport function createStructuredMessageStatement({ message, chainId }: StructuredMessage) {\n  // `statement` does not allow newlines, so we escape them\n  const escapedMessage = message.replaceAll('\\n', '\\\\n');\n\n  const onAptosChainSuffix = chainId ? ` (${getChainName(chainId)})` : '';\n  const onAptosChain = ` on Aptos blockchain${onAptosChainSuffix}`;\n\n  return `To sign the following message${onAptosChain}: ${escapedMessage}`;\n}\n\n/**\n * Create a human-readable statement for the specified Aptos transaction,\n * suitable to be included into a \"Sign in with ...\" envelope.\n */\nexport function createTransactionStatement(rawTransaction: AnyRawTransaction) {\n  const entryFunctionName = getEntryFunctionName(rawTransaction.rawTransaction.payload);\n  const humanReadableEntryFunction = entryFunctionName ? ` ${entryFunctionName}` : '';\n\n  const chainId = rawTransaction.rawTransaction.chain_id.chainId;\n  const chainName = getChainName(chainId);\n  const onAptosChain = ` on Aptos blockchain (${chainName})`;\n\n  return `To execute transaction${humanReadableEntryFunction}${onAptosChain}.`;\n}\n","import {\n  AnyRawTransaction,\n  Deserializer, FeePayerRawTransaction,\n  hashValues, Hex, HexInput, MultiAgentRawTransaction, MultiAgentTransaction,\n  RAW_TRANSACTION_SALT,\n  RAW_TRANSACTION_WITH_DATA_SALT,\n  RawTransaction,\n  RawTransactionWithData, SimpleTransaction,\n} from '@aptos-labs/ts-sdk';\nimport { decodeStructuredMessage, StructuredMessage } from './StructuredMessage';\n\nfunction bufferStartsWith(buffer: Uint8Array, search: Uint8Array) {\n  return buffer.slice(0, search.length) === search;\n}\n\nconst transactionSigningMessagePrefix = hashValues([RAW_TRANSACTION_SALT]);\nconst transactionWithDataSigningMessagePrefix = hashValues([RAW_TRANSACTION_WITH_DATA_SALT]);\n\nexport function parseRawTransaction(message: Uint8Array) {\n  if (bufferStartsWith(message, transactionSigningMessagePrefix)) {\n    const serialized = message.slice(transactionSigningMessagePrefix.length);\n    const deserializer = new Deserializer(serialized);\n    return RawTransaction.deserialize(deserializer);\n  } else if (bufferStartsWith(message, transactionWithDataSigningMessagePrefix)) {\n    const serialized = message.slice(transactionWithDataSigningMessagePrefix.length);\n    const deserializer = new Deserializer(serialized);\n    return RawTransactionWithData.deserialize(deserializer);\n  }\n  return undefined;\n}\n\nexport interface ParseSigningMessageTransactionResult {\n  type: 'transaction',\n  rawTransaction: AnyRawTransaction;\n}\n\nexport interface ParseSigningMessageStructuredMessageResult {\n  type: 'structuredMessage',\n  structuredMessage: StructuredMessage;\n}\n\nexport type ParseSigningMessageResult =\n  | ParseSigningMessageTransactionResult\n  | ParseSigningMessageStructuredMessageResult;\n\nexport function parseAptosSigningMessage(message: HexInput): ParseSigningMessageResult | undefined {\n  const messageBytes = Hex.fromHexInput(message).toUint8Array();\n\n  const parsedRawTransaction = parseRawTransaction(messageBytes);\n  if (parsedRawTransaction) {\n    let rawTransaction: AnyRawTransaction;\n    if (parsedRawTransaction instanceof RawTransaction) {\n      rawTransaction = new SimpleTransaction(parsedRawTransaction);\n    } else if (parsedRawTransaction instanceof MultiAgentRawTransaction) {\n      rawTransaction = new MultiAgentTransaction(\n        parsedRawTransaction.raw_txn,\n        parsedRawTransaction.secondary_signer_addresses,\n      );\n    } else if (parsedRawTransaction instanceof FeePayerRawTransaction) {\n      const { raw_txn, secondary_signer_addresses, fee_payer_address } = parsedRawTransaction;\n      rawTransaction = secondary_signer_addresses.length > 0\n        ? new MultiAgentTransaction(raw_txn, secondary_signer_addresses, fee_payer_address)\n        : new SimpleTransaction(raw_txn, fee_payer_address);\n    } else {\n      throw new Error('Unsupported raw transaction');\n    }\n    return {\n      type: 'transaction',\n      rawTransaction\n    };\n  }\n\n  try {\n    const structuredMessage = decodeStructuredMessage(messageBytes);\n    return {\n      type: 'structuredMessage',\n      structuredMessage,\n    };\n  } catch (err) {\n    return undefined;\n  }\n}\n","import { AccountAddressInput } from '@aptos-labs/ts-sdk';\n\nexport const structuredMessagePrefix = 'APTOS' as const;\n\nexport interface StructuredMessageInput {\n  message: string;\n  nonce: string;\n  application?: boolean;\n  chainId?: number | boolean;\n  address?: AccountAddressInput | boolean;\n}\n\nexport interface StructuredMessage {\n  message: string;\n  nonce: string;\n  application?: string;\n  chainId?: number;\n  address?: string;\n}\n\nexport function encodeStructuredMessage(structuredMessage: StructuredMessage): Uint8Array {\n  const { address, application, chainId, message, nonce } = structuredMessage;\n\n  const optionalParts: string[] = [];\n  if (address !== undefined) {\n    optionalParts.push(`address: ${address}`);\n  }\n  if (application !== undefined) {\n    optionalParts.push(`application: ${application}`);\n  }\n  if (chainId !== undefined) {\n    optionalParts.push(`chainId: ${chainId}`);\n  }\n\n  const parts = [\n    structuredMessagePrefix,\n    ...optionalParts,\n    `message: ${message}`,\n    `nonce: ${nonce}`,\n  ];\n\n  const input = parts.join('\\n');\n  return new TextEncoder().encode(input);\n}\n\nfunction parsePart(part: string, name: string) {\n  const partPrefix = `${name}: `;\n  return part.startsWith(partPrefix) ? part.slice(partPrefix.length) : undefined;\n}\n\nexport function decodeStructuredMessage(encoded: Uint8Array): StructuredMessage {\n  const utf8Decoded = new TextDecoder().decode(encoded);\n  const [prefix, ...parts] = utf8Decoded.split('\\n');\n  if (prefix !== structuredMessagePrefix) {\n    throw new Error('Invalid message prefix');\n  }\n\n  let i = 0;\n\n  const address = parsePart(parts[i], 'address');\n  if (address !== undefined) {\n    i += 1;\n  }\n\n  const application = parsePart(parts[i], 'application');\n  if (application !== undefined) {\n    i += 1;\n  }\n\n  const chainIdStr = parsePart(parts[i], 'chainId');\n  if (chainIdStr !== undefined) {\n    i += 1;\n  }\n\n  const nonce = parsePart(parts[parts.length - 1], 'nonce');\n  if (!nonce) {\n    throw new Error('Expected nonce');\n  }\n\n  const messageParts = parts.slice(i, parts.length - 1).join('\\n');\n  const message = parsePart(messageParts, 'message');\n  if (!message) {\n    throw new Error('Expected message');\n  }\n\n  return {\n    address,\n    application,\n    chainId: chainIdStr ? Number(chainIdStr) : undefined,\n    message,\n    nonce,\n  };\n}\n","import {\n  UserApproval,\n  UserRejection,\n  UserResponse,\n  UserResponseStatus,\n} from '@aptos-labs/wallet-standard';\n\nexport function makeUserApproval<T>(args: T): UserApproval<T> {\n  return {\n    status: UserResponseStatus.APPROVED,\n    args,\n  };\n}\n\nexport function makeUserRejection(): UserRejection {\n  return { status: UserResponseStatus.REJECTED };\n}\n\nexport type MaybeAsync<T> = T | Promise<T>;\n\nexport function mapUserResponse<Src, Dst>(response: UserResponse<Src>, mapFn: (src: Src) => Dst): UserResponse<Dst>\nexport function mapUserResponse<Src, Dst>(response: UserResponse<Src>, mapFn: (src: Src) => Promise<Dst>): Promise<UserResponse<Dst>>\nexport function mapUserResponse<Src, Dst>(response: UserResponse<Src>, mapFn: (src: Src) => MaybeAsync<Dst>): MaybeAsync<UserResponse<Dst>> {\n  if (response.status === UserResponseStatus.REJECTED) {\n    return makeUserRejection();\n  }\n  const mappedResponse = mapFn(response.args);\n  return mappedResponse instanceof Promise\n    ? mappedResponse.then((args) => makeUserApproval(args))\n    : makeUserApproval(mappedResponse);\n}\n","import { AccountPublicKey, Aptos } from '@aptos-labs/ts-sdk';\nimport { AccountInfo } from '@aptos-labs/wallet-standard';\n\nexport function accountInfoFromPublicKey(publicKey: AccountPublicKey) {\n  return new AccountInfo({\n    publicKey,\n    address: publicKey.authKey().derivedAddress(),\n  })\n}\n\nexport function isNullCallback(callback: Function) {\n  return '_isNull' in callback && callback._isNull === true;\n}\n\n/**\n * Helper function to fetch Devnet chain id\n */\nexport const fetchDevnetChainId = async (): Promise<number> => {\n  const aptos = new Aptos(); // default to devnet\n  return await aptos.getChainId();\n};"],"mappings":";AAAA;AAAA,EACE;AAAA,EACA;AAAA,EAEA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,OACK;AAKA,IAAM,2BAA2B;AAQjC,SAAS,kCACd,cACA,UACA,QACmB;AACnB,MAAI;AAEF,QAAI,CAAC,oBAAoB,YAAY,GAAG;AACtC,YAAM,IAAI,MAAM,mCAAmC,YAAY,EAAE;AAAA,IACnE;AACA,UAAM,CAAC,eAAe,YAAY,YAAY,IAAI,aAAa,MAAM,IAAI;AAGzE,UAAM,aAAa,IAAI,WAAW;AAClC,mBAAe,WAAW,aAAa,EAAE,UAAU,UAAU;AAC7D,eAAW,aAAa,UAAU;AAClC,eAAW,aAAa,YAAY;AAGpC,UAAM,KAAK,IAAI,WAAW;AAC1B,UAAM,oBAAoB,IAAI,2BAA2B,UAAU,MAAM;AACzE,OAAG,eAAe,kBAAkB,WAAW,CAAC;AAGhD,UAAM,kBAAkB,IAAI,WAAW,CAAC,wBAAwB,CAAC;AAEjE,UAAM,OAAO,WAAW;AAAA,MACtB,WAAW,aAAa;AAAA,MACxB,GAAG,aAAa;AAAA,MAChB;AAAA,IACF,CAAC;AAED,WAAO,IAAI,kBAAkB,EAAE,KAAK,CAAC;AAAA,EACvC,SAAS,GAAG;AACV,UAAM,8CAA8C,CAAC;AAAA,EACvD;AACF;AAQO,IAAM,6BAAN,MAAM,oCAAmC,aAAa;AAAA,EAC3D,YACS,UACA,QACP;AACA,UAAM;AAHC;AACA;AAAA,EAGT;AAAA,EAEA,UAAU,YAA8B;AACtC,eAAW,aAAa,KAAK,QAAQ;AACrC,eAAW,aAAa,KAAK,MAAM;AAAA,EACrC;AAAA,EAEA,OAAO,YAAY,cAAwD;AACzE,UAAM,WAAW,aAAa,eAAe;AAC7C,UAAM,SAAS,aAAa,eAAe;AAC3C,WAAO,IAAI,4BAA2B,UAAU,MAAM;AAAA,EACxD;AACF;;;ACnFA;AAAA,EAEE;AAAA,EAEA;AAAA,OACK;AAMP,SAAS,aAAa,SAAiB;AAErC,aAAW,CAAC,SAAS,YAAY,KAAK,OAAO,QAAQ,gBAAgB,GAAG;AACtE,QAAI,iBAAiB,SAAS;AAC5B,aAAO;AAAA,IACT;AAAA,EACF;AAEA,SAAO,mBAAmB,OAAO;AACnC;AAKO,SAAS,qBAAqB,SAA6B;AAChE,MAAI,EAAE,mBAAmB,kCAAkC;AACzD,WAAO;AAAA,EACT;AACA,QAAM,gBAAgB,QAAQ,cAAc,YAAY,QAAQ,SAAS;AACzE,QAAM,aAAa,QAAQ,cAAc,YAAY,KAAK;AAC1D,QAAM,eAAe,QAAQ,cAAc,cAAc;AACzD,SAAO,GAAG,aAAa,KAAK,UAAU,KAAK,YAAY;AACzD;AAMO,SAAS,iCAAiC,EAAE,SAAS,QAAQ,GAAsB;AAExF,QAAM,iBAAiB,QAAQ,WAAW,MAAM,KAAK;AAErD,QAAM,qBAAqB,UAAU,KAAK,aAAa,OAAO,CAAC,MAAM;AACrE,QAAM,eAAe,uBAAuB,kBAAkB;AAE9D,SAAO,gCAAgC,YAAY,KAAK,cAAc;AACxE;AAMO,SAAS,2BAA2B,gBAAmC;AAC5E,QAAM,oBAAoB,qBAAqB,eAAe,eAAe,OAAO;AACpF,QAAM,6BAA6B,oBAAoB,IAAI,iBAAiB,KAAK;AAEjF,QAAM,UAAU,eAAe,eAAe,SAAS;AACvD,QAAM,YAAY,aAAa,OAAO;AACtC,QAAM,eAAe,yBAAyB,SAAS;AAEvD,SAAO,yBAAyB,0BAA0B,GAAG,YAAY;AAC3E;;;AC9DA;AAAA,EAEE,gBAAAA;AAAA,EAAc;AAAA,EACd,cAAAC;AAAA,EAAY;AAAA,EAAe;AAAA,EAA0B;AAAA,EACrD;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EAAwB;AAAA,OACnB;;;ACNA,IAAM,0BAA0B;AAkBhC,SAAS,wBAAwB,mBAAkD;AACxF,QAAM,EAAE,SAAS,aAAa,SAAS,SAAS,MAAM,IAAI;AAE1D,QAAM,gBAA0B,CAAC;AACjC,MAAI,YAAY,QAAW;AACzB,kBAAc,KAAK,YAAY,OAAO,EAAE;AAAA,EAC1C;AACA,MAAI,gBAAgB,QAAW;AAC7B,kBAAc,KAAK,gBAAgB,WAAW,EAAE;AAAA,EAClD;AACA,MAAI,YAAY,QAAW;AACzB,kBAAc,KAAK,YAAY,OAAO,EAAE;AAAA,EAC1C;AAEA,QAAM,QAAQ;AAAA,IACZ;AAAA,IACA,GAAG;AAAA,IACH,YAAY,OAAO;AAAA,IACnB,UAAU,KAAK;AAAA,EACjB;AAEA,QAAM,QAAQ,MAAM,KAAK,IAAI;AAC7B,SAAO,IAAI,YAAY,EAAE,OAAO,KAAK;AACvC;AAEA,SAAS,UAAU,MAAc,MAAc;AAC7C,QAAM,aAAa,GAAG,IAAI;AAC1B,SAAO,KAAK,WAAW,UAAU,IAAI,KAAK,MAAM,WAAW,MAAM,IAAI;AACvE;AAEO,SAAS,wBAAwB,SAAwC;AAC9E,QAAM,cAAc,IAAI,YAAY,EAAE,OAAO,OAAO;AACpD,QAAM,CAAC,QAAQ,GAAG,KAAK,IAAI,YAAY,MAAM,IAAI;AACjD,MAAI,WAAW,yBAAyB;AACtC,UAAM,IAAI,MAAM,wBAAwB;AAAA,EAC1C;AAEA,MAAI,IAAI;AAER,QAAM,UAAU,UAAU,MAAM,CAAC,GAAG,SAAS;AAC7C,MAAI,YAAY,QAAW;AACzB,SAAK;AAAA,EACP;AAEA,QAAM,cAAc,UAAU,MAAM,CAAC,GAAG,aAAa;AACrD,MAAI,gBAAgB,QAAW;AAC7B,SAAK;AAAA,EACP;AAEA,QAAM,aAAa,UAAU,MAAM,CAAC,GAAG,SAAS;AAChD,MAAI,eAAe,QAAW;AAC5B,SAAK;AAAA,EACP;AAEA,QAAM,QAAQ,UAAU,MAAM,MAAM,SAAS,CAAC,GAAG,OAAO;AACxD,MAAI,CAAC,OAAO;AACV,UAAM,IAAI,MAAM,gBAAgB;AAAA,EAClC;AAEA,QAAM,eAAe,MAAM,MAAM,GAAG,MAAM,SAAS,CAAC,EAAE,KAAK,IAAI;AAC/D,QAAM,UAAU,UAAU,cAAc,SAAS;AACjD,MAAI,CAAC,SAAS;AACZ,UAAM,IAAI,MAAM,kBAAkB;AAAA,EACpC;AAEA,SAAO;AAAA,IACL;AAAA,IACA;AAAA,IACA,SAAS,aAAa,OAAO,UAAU,IAAI;AAAA,IAC3C;AAAA,IACA;AAAA,EACF;AACF;;;ADjFA,SAAS,iBAAiB,QAAoB,QAAoB;AAChE,SAAO,OAAO,MAAM,GAAG,OAAO,MAAM,MAAM;AAC5C;AAEA,IAAM,kCAAkCC,YAAW,CAAC,oBAAoB,CAAC;AACzE,IAAM,0CAA0CA,YAAW,CAAC,8BAA8B,CAAC;AAEpF,SAAS,oBAAoB,SAAqB;AACvD,MAAI,iBAAiB,SAAS,+BAA+B,GAAG;AAC9D,UAAM,aAAa,QAAQ,MAAM,gCAAgC,MAAM;AACvE,UAAM,eAAe,IAAIC,cAAa,UAAU;AAChD,WAAO,eAAe,YAAY,YAAY;AAAA,EAChD,WAAW,iBAAiB,SAAS,uCAAuC,GAAG;AAC7E,UAAM,aAAa,QAAQ,MAAM,wCAAwC,MAAM;AAC/E,UAAM,eAAe,IAAIA,cAAa,UAAU;AAChD,WAAO,uBAAuB,YAAY,YAAY;AAAA,EACxD;AACA,SAAO;AACT;AAgBO,SAAS,yBAAyB,SAA0D;AACjG,QAAM,eAAe,IAAI,aAAa,OAAO,EAAE,aAAa;AAE5D,QAAM,uBAAuB,oBAAoB,YAAY;AAC7D,MAAI,sBAAsB;AACxB,QAAI;AACJ,QAAI,gCAAgC,gBAAgB;AAClD,uBAAiB,IAAI,kBAAkB,oBAAoB;AAAA,IAC7D,WAAW,gCAAgC,0BAA0B;AACnE,uBAAiB,IAAI;AAAA,QACnB,qBAAqB;AAAA,QACrB,qBAAqB;AAAA,MACvB;AAAA,IACF,WAAW,gCAAgC,wBAAwB;AACjE,YAAM,EAAE,SAAS,4BAA4B,kBAAkB,IAAI;AACnE,uBAAiB,2BAA2B,SAAS,IACjD,IAAI,sBAAsB,SAAS,4BAA4B,iBAAiB,IAChF,IAAI,kBAAkB,SAAS,iBAAiB;AAAA,IACtD,OAAO;AACL,YAAM,IAAI,MAAM,6BAA6B;AAAA,IAC/C;AACA,WAAO;AAAA,MACL,MAAM;AAAA,MACN;AAAA,IACF;AAAA,EACF;AAEA,MAAI;AACF,UAAM,oBAAoB,wBAAwB,YAAY;AAC9D,WAAO;AAAA,MACL,MAAM;AAAA,MACN;AAAA,IACF;AAAA,EACF,SAAS,KAAK;AACZ,WAAO;AAAA,EACT;AACF;;;AEjFA;AAAA,EAIE;AAAA,OACK;AAEA,SAAS,iBAAoB,MAA0B;AAC5D,SAAO;AAAA,IACL,QAAQ,mBAAmB;AAAA,IAC3B;AAAA,EACF;AACF;AAEO,SAAS,oBAAmC;AACjD,SAAO,EAAE,QAAQ,mBAAmB,SAAS;AAC/C;AAMO,SAAS,gBAA0B,UAA6B,OAAqE;AAC1I,MAAI,SAAS,WAAW,mBAAmB,UAAU;AACnD,WAAO,kBAAkB;AAAA,EAC3B;AACA,QAAM,iBAAiB,MAAM,SAAS,IAAI;AAC1C,SAAO,0BAA0B,UAC7B,eAAe,KAAK,CAAC,SAAS,iBAAiB,IAAI,CAAC,IACpD,iBAAiB,cAAc;AACrC;;;AC9BA,SAA2B,aAAa;AACxC,SAAS,mBAAmB;AAErB,SAAS,yBAAyB,WAA6B;AACpE,SAAO,IAAI,YAAY;AAAA,IACrB;AAAA,IACA,SAAS,UAAU,QAAQ,EAAE,eAAe;AAAA,EAC9C,CAAC;AACH;AAEO,SAAS,eAAe,UAAoB;AACjD,SAAO,aAAa,YAAY,SAAS,YAAY;AACvD;AAKO,IAAM,qBAAqB,YAA6B;AAC7D,QAAM,QAAQ,IAAI,MAAM;AACxB,SAAO,MAAM,MAAM,WAAW;AAChC;","names":["Deserializer","hashValues","hashValues","Deserializer"]}